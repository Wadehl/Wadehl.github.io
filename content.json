{"meta":{"title":"Venkiˡᵒᵛᵉ💕","subtitle":"","description":"Hope One Day I Could Be A Full Stack Engineer & A UI Designer","author":"Kevin","url":"http://dayswithvenki.top","root":"/"},"pages":[{"title":"关于Kevin&&Venki","date":"2022-03-02T02:32:00.000Z","updated":"2022-07-05T04:16:50.142Z","comments":true,"path":"about/index.html","permalink":"http://dayswithvenki.top/about/index.html","excerpt":"","text":"css文件好像加载失败了。字体不一样的字可以点击，然后继续。 正在尝试把botui移动到侧边栏啦~ 已将原有的内容更新，并且移动到侧边栏成功咯 [talk with Kevin] 与&nbsp; Kevin&nbsp; （ bot Kevin bot ） 对话中... bot_ui_ini() 联系我B站：我永远爱小吴崽 QQ：1171407839"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-27T12:40:24.587Z","comments":true,"path":"archives/index.html","permalink":"http://dayswithvenki.top/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2022-07-06T03:01:56.456Z","comments":false,"path":"categories/index.html","permalink":"http://dayswithvenki.top/categories/index.html","excerpt":"","text":""},{"title":"郭崽日报","date":"2022-07-04T14:06:17.000Z","updated":"2022-07-06T07:33:07.105Z","comments":false,"path":"bb/index.html","permalink":"http://dayswithvenki.top/bb/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"http://dayswithvenki.top/comments/index.html","excerpt":"","text":""},{"title":"课表","date":"2022-03-03T16:00:00.000Z","updated":"2022-05-19T02:14:00.951Z","comments":false,"path":"classes/index.html","permalink":"http://dayswithvenki.top/classes/index.html","excerpt":"","text":"课表"},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2022-05-19T02:14:00.951Z","comments":true,"path":"music/index.html","permalink":"http://dayswithvenki.top/music/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"http://dayswithvenki.top/link/index.html","excerpt":"","text":""},{"title":"","date":"2022-03-31T01:28:46.808Z","updated":"2022-03-31T01:28:46.808Z","comments":true,"path":"codepen/house.css","permalink":"http://dayswithvenki.top/codepen/house.css","excerpt":"","text":"* { box-sizing: border-box; } ba { display: flex; align-items: center; justify-content: flex-end; flex-direction: column; height: 90vh; background: #a2d8f3; } .body { position: relative; } .roof .top { width: calc(100% + 2 * calc(2 * 1vmin)); background: linear-gradient(#dd9980, #dd9980 50%, #af5842 50%); height: calc(2 * 1vmin); position: relative; left: calc(-2 * 1vmin); } .roof .top:before { content: \"\"; position: absolute; bottom: 0; left: 0; width: 0; height: 0; border-style: solid; border-width: 1vmin 0 0 1vmin; border-color: transparent transparent transparent #a2d8f3; } .roof .top:after { content: \"\"; position: absolute; bottom: 0; right: 0; width: 0; height: 0; border-style: solid; border-width: 0 0 1vmin 1vmin; border-color: transparent transparent #a2d8f3 transparent; } .roof .middle { width: calc(100% + calc(2 * 1vmin)); background-image: linear-gradient( 90deg, #d8785b 25%, #af5842 25%, #af5842 50%, #d8785b 50%, #d8785b 75%, #af5842 75%, #af5842 100% ); background-size: calc(6 * 1vmin) calc(6 * 1vmin); height: calc(2 * 1vmin); position: relative; left: calc(-1 * 1vmin); } .roof .bottom { width: 100%; background: #af5842; height: calc(4 * 1vmin); display: flex; align-items: center; justify-content: space-around; padding: 0 1vmin; } .roof .bottom span { border: calc(0.75 * 1vmin) solid #86432f; border-bottom: none; width: calc(80% / 4); height: 100%; position: relative; } .roof .bottom span:before { content: \"\"; position: absolute; bottom: 0; left: 0; right: 0; margin: 0 auto; background: #86432f; height: calc(2 * 1vmin); width: calc(4 * 1vmin); border-top-right-radius: calc(2 * 1vmin); border-top-left-radius: calc(2 * 1vmin); } .chimney1 { width: calc(3 * 1vmin); height: calc(4 * 1vmin); background: #d8785b; position: absolute; left: calc(6 * 1vmin); top: calc(-4 * 1vmin); } .chimney1:before { position: absolute; top: 0; content: \"\"; width: calc(100% + 1vmin); left: calc(-0.5 * 1vmin); height: 1vmin; background: #dd9980; } .chimney2 { width: calc(6 * 1vmin); height: calc(4 * 1vmin); background: #d8785b; position: absolute; left: calc(12 * 1vmin); top: calc(-4 * 1vmin); } .chimney2:before { position: absolute; top: 0; content: \"\"; width: calc(100% + 1vmin); left: calc(-0.5 * 1vmin); height: 1vmin; background: #dd9980; } .antenna { position: absolute; right: calc(8 * 1vmin); top: calc(-7 * 1vmin); width: 1vmin; height: calc(7 * 1vmin); background: #889bad; } .antenna:before { content: \"\"; position: absolute; height: 1vmin; width: calc(10 * 1vmin); left: calc(-4.5 * 1vmin); top: 1vmin; background: #889bad; } .antenna span { position: absolute; width: 1vmin; background: #889bad; } .antenna .ant1 { height: calc(4 * 1vmin); left: calc(-4.5 * 1vmin); top: calc(-0.5 * 1vmin); } .antenna .ant2 { height: calc(3 * 1vmin); left: calc(-2 * 1vmin); } .antenna .ant3 { height: calc(3 * 1vmin); right: calc(-2 * 1vmin); } .antenna .ant4 { height: calc(4 * 1vmin); right: calc(-4.5 * 1vmin); top: calc(-0.5 * 1vmin); } .floor { width: calc(2 * calc(20 * 1vmin)); height: calc(20 * 1vmin); background: #d8785b; border-top: #af5842 solid calc(2 * 1vmin); position: relative; display: flex; align-items: flex-start; justify-content: space-around; } .floor:before { content: \"\"; position: absolute; top: calc(-2 * 1vmin); left: -1vmin; height: 1vmin; width: calc(100% + 2 * 1vmin); background: #dd9980; } .window { position: relative; top: calc(4 * 1vmin); width: calc(1vmin * 6); height: calc(1vmin * 10); } .window:before { content: \"\"; position: absolute; top: 50%; width: 100%; height: 1vmin; background: #573026; } .windowFrame { height: 100%; width: 100%; background: #62a1cb; border: 1vmin solid #573026; } .windowTop { height: 1vmin; width: calc(100% + 2 * 1vmin); position: absolute; left: -1vmin; background: #dd9980; z-index: 1; top: -1vmin; } .windowTop:before { content: \"\"; position: absolute; top: calc(-2 * 1vmin); width: 0; height: 0; border-style: solid; border-width: 0 calc(4 * 1vmin) calc(2 * 1vmin) calc(4 * 1vmin); border-color: transparent transparent #dd9980 transparent; } .windowTop:after { content: \"\"; position: absolute; top: calc(-1 * 1vmin); left: 0; right: 0; width: 0; height: 0; margin: 0 auto; border-style: solid; border-width: 0 1vmin 1vmin 1vmin; border-color: transparent transparent #af5842 transparent; opacity: 0.7; } .windowBottom { height: calc(2 * 1vmin); width: calc(100% + 2 * 1vmin); position: absolute; left: -1vmin; background: linear-gradient(#dd9980 0, #dd9980 50%, #86432f 50%); } .window9 { visibility: hidden; opacity: 0; } .window1 .windowFrame { background: linear-gradient( 90deg, #fec864 1vmin, #fec864 1vmin, #aa803e 1vmin, #aa803e calc(2 * 1vmin), #fec864 calc(2 * 1vmin) ); } .window2 .windowFrame, .window4 .windowFrame, .window7 .windowFrame { background: linear-gradient( -225deg, #62a1cb, #62a1cb 1vmin, #82c7d0 1vmin, #82c7d0 2vmin, #62a1cb 2vmin, #62a1cb 3vmin, #82c7d0 3vmin, #82c7d0 4vmin, #62a1cb 4vmin ); } .window3 .windowFrame { background: linear-gradient(#62a1cb, #62a1cb 50%, #aa803e 50%); } .window5 .windowFrame { background: linear-gradient( 90deg, #fec864, #fec864 calc(2 * 1vmin), #aa803e calc(2 * 1vmin) ); } .window6 .windowFrame { background: #fec864; } .window8 .windowFrame { background: linear-gradient( -225deg, #62a1cb, #62a1cb 1vmin, #82c7d0 1vmin, #82c7d0 calc(2.5 * 1vmin), #62a1cb calc(2.5 * 1vmin) ); } .zeroLevel { width: 100%; height: calc(8 * 1vmin); position: relative; background: linear-gradient( #7f6a4d, #7f6a4d 1vmin, #523127 1vmin, #523127 calc(2 * 1vmin), #7f6a4d calc(2 * 1vmin) ); } .stairs { height: calc(5 * 1vmin); width: 33%; background: #71372e; position: absolute; bottom: 0; right: 0; background-image: linear-gradient( 0deg, #523127 30%, #7f6a4d 30%, #7f6a4d 50%, #523127 50%, #523127 80%, #7f6a4d 80%, #7f6a4d 100% ); background-size: calc(4 * 1vmin) calc(4 * 1vmin); } .stairs .wall { position: absolute; top: calc(-1 * 1vmin); width: calc(3 * 1vmin); height: calc(5 * 1vmin); background: #86432f; border: 1vmin solid #d8785b; } .stairs .wall:before { content: \"\"; position: absolute; bottom: calc(-2 * 1vmin); left: calc(-1.5 * 1vmin); height: calc(2 * 1vmin); width: calc(4 * 1vmin); background: #dd9980; } .stairs .wall:after { content: \"\"; position: absolute; top: calc(-2 * 1vmin); left: calc(-1.5 * 1vmin); height: calc(2 * 1vmin); width: calc(4 * 1vmin); background: #dd9980; } .stairs .wall1 { left: calc(-0.5 * 1vmin); } .stairs .wall2 { right: calc(-0.5 * 1vmin); } .doorWrapper { height: calc(calc(20 * 1vmin) - calc(2 * 1vmin)); width: 33%; background: #71372e; position: absolute; bottom: calc(8 * 1vmin); right: 0; border: calc(2.5 * 1vmin) solid #7f6a4d; border-top-width: calc(3 * 1vmin); border-bottom: 0; display: flex; } .doorWrapper:before { content: \"\"; position: absolute; top: 0; left: 0; right: 0; height: 1vmin; background: #46221c; } .doorWrapper .topLight { position: absolute; width: 70%; margin: 0 auto; top: calc(1.5 * 1vmin); left: 0; right: 0; background: linear-gradient( 90deg, #fec864, #fec864, 21%, transparent 21%, transparent 33.3%, #aa803e 33.3%, #aa803e 67%, transparent 67%, transparent 73%, #fec864 81%, #fec864 100% ); height: 1vmin; } .doorWrapper .cornice { position: absolute; width: calc(4 * 1vmin); height: 1vmin; background: #9f8560; } .doorWrapper .cornice:before { content: \"\"; position: absolute; top: calc(1 * 1vmin); border-top: 1vmin solid #5f503a; border-left: 1vmin solid transparent; border-right: 1vmin solid transparent; height: 0; width: calc(2 * 1vmin); } .doorWrapper .cornice1 { left: calc(-3 * 1vmin); } .doorWrapper .cornice2 { right: calc(-3 * 1vmin); } .doorWrapper .handrail { position: absolute; width: 100%; bottom: 0; } .doorWrapper .handrail .right { height: calc(6 * 1vmin); width: 1vmin; background: #523127; display: block; position: absolute; right: calc(-1.75 * 1vmin); bottom: 0; } .doorWrapper .handrail .right:before { content: \"\"; width: calc(1.5 * 1vmin); height: calc(1.5 * 1vmin); border-radius: 100%; background: #523127; position: absolute; right: calc(-0.25 * 1vmin); } .doorWrapper .handrail .left { height: calc(6 * 1vmin); width: 1vmin; background: #523127; display: block; position: absolute; left: calc(-1.75 * 1vmin); bottom: 0; } .doorWrapper .handrail .left:before { content: \"\"; width: calc(1.5 * 1vmin); height: calc(1.5 * 1vmin); border-radius: 100%; background: #523127; position: absolute; top: 0; left: calc(-0.25 * 1vmin); } .doorWrapper .door { width: 70%; margin: auto auto 0 auto; height: 80%; background: #71372e; border: calc(2 * 1vmin) solid #523127; border-bottom-width: calc(2 * 1vmin); border-top-width: calc(2 * 1vmin); position: relative; } .doorWrapper .door:before { content: \"\"; position: absolute; top: 40%; left: 0; right: 0; margin: 0 auto; background: #523127; width: 1vmin; height: 1vmin; border-radius: 50%; } .balcony { position: absolute; bottom: calc(-1 * 1vmin); left: calc(-9 * 1vmin); width: calc(9 * 1vmin); height: 1vmin; background: #af5842; } .balcony .grid { position: absolute; left: 0; bottom: calc(2 * 1vmin); width: calc(9 * 1vmin); height: calc(7 * 1vmin); background-image: linear-gradient( 90deg, #484551 16.67%, #a2d8f3 16.67%, #a2d8f3 50%, #484551 50%, #484551 66.67%, #a2d8f3 66.67%, #a2d8f3 100% ); background-size: calc(6 * calc(0.5 * 1vmin)); } .balcony .grid span { width: calc(0.5 * 1vmin); height: calc(1 * 1vmin); display: block; background: #484551; position: absolute; bottom: calc(-1 * 1vmin); } .balcony .grid:before { content: \"\"; position: absolute; left: 0; top: 0; width: calc(9 * 1vmin); height: calc(0.5 * 1vmin); background: #484551; } .balcony .grid:after { content: \"\"; position: absolute; left: 0; bottom: 0; width: calc(9 * 1vmin); height: calc(0.5 * 1vmin); background: #484551; } .balcony .flower { width: calc(2 * 1vmin); height: 1vmin; background: #7f6a4d; position: absolute; top: calc(-9 * 1vmin); } .balcony .flower:before { content: \"\"; width: calc(3 * 1vmin); height: calc(3 * 1vmin); transform: rotate(-45deg); position: absolute; top: calc(-4.5 * 1vmin); right: calc(-0.5 * 1vmin); background: #98b854; } .ladder { width: calc(4 * 1vmin); height: calc(1.7 * calc(20 * 1vmin)); position: absolute; left: calc(-4 * 1vmin); bottom: 13vmin; background-image: linear-gradient( 0deg, #484551 16.67%, #a2d8f3 16.67%, #a2d8f3 50%, #484551 50%, #484551 66.67%, #a2d8f3 66.67%, #a2d8f3 100% ); background-size: calc(10 * calc(0.5 * 1vmin)) calc(10 * calc(0.5 * 1vmin)); z-index: -1; } .ladder:before { content: \"\"; position: absolute; top: 0; left: 0; background: #484551; height: 105%; width: calc(0.5 * 1vmin); } .tree { position: absolute; width: calc(6 * 1vmin); height: calc(8 * 1vmin); background: linear-gradient(90deg, #98b854, #98b854 50%, #76812f 50%); } .tree:before { content: \"\"; position: absolute; width: calc(4 * 1vmin); height: calc(2 * 1vmin); background: #76812f; left: calc(1 * 1vmin); top: calc(-2 * 1vmin); } .tree:after { content: \"\"; position: absolute; width: calc(4 * 1vmin); height: calc(2 * 1vmin); background: #5c7523; left: calc(1 * 1vmin); bottom: calc(-2 * 1vmin); } .tree .trunk { width: 1vmin; height: calc(4 * 1vmin); background: #fff; position: absolute; bottom: calc(-6 * 1vmin); left: calc(2.5 * 1vmin); } .tree .pot { width: calc(4 * 1vmin); height: 1vmin; background: #98b854; position: absolute; bottom: calc(-6.5 * 1vmin); left: calc(1 * 1vmin); } .tree .pot:before { content: \"\"; position: absolute; height: calc(2 * 1vmin); width: calc(5 * 1vmin); background: #484551; bottom: calc(-2 * 1vmin); left: calc(-0.5 * 1vmin); } .tree1 { top: calc(-8.5 * 1vmin); right: calc(-7 * 1vmin); } .tree2 { top: calc(-8.5 * 1vmin); right: calc(14 * 1vmin); } .hydrant { position: absolute; left: calc(-7 * 1vmin); bottom: calc(0.5 * 1vmin); width: calc(3 * 1vmin); height: calc(4 * 1vmin); background: #ca3133; border: 1vmin solid #d65859; } .hydrant:before { content: \"\"; position: absolute; bottom: calc(-1.5 * 1vmin); left: calc(-1.5 * 1vmin); width: calc(4 * 1vmin); height: calc(0.5 * 1vmin); background: #d65859; } .hydrant:after { content: \"\"; position: absolute; top: calc(-1.5 * 1vmin); left: calc(-1.5 * 1vmin); width: calc(4 * 1vmin); height: 1vmin; background: #d65859; } .hydrant span { position: absolute; top: calc(-2.5 * 1vmin); left: calc(-0.5 * 1vmin); width: calc(2 * 1vmin); height: calc(2 * 1vmin); border-radius: 50%; background: #ca3133; } .hydrant span:before { content: \"\"; position: absolute; width: calc(0.5 * 1vmin); height: calc(0.5 * 1vmin); background: #d65859; right: calc(0.8 * 1vmin); top: calc(-0.5 * 1vmin); } .fence { display: flex; position: absolute; bottom: 0; left: calc(-2 * 1vmin); } .fenceSpan { width: calc(5.5 * 1vmin); height: calc(4 * 1vmin); border: calc(0.5 * 1vmin) solid #523127; border-bottom: none; position: relative; } .fenceSpan:before { content: \"\"; position: absolute; width: calc(5.5 * 1vmin); left: calc(-0.5 * 1vmin); top: calc(2 * 1vmin); height: calc(0.5 * 1vmin); background: #523127; } .fenceSpan:after { content: \"\"; position: absolute; width: calc(0.5 * 1vmin); left: calc(2 * 1vmin); top: calc(-0.5 * 1vmin); height: calc(3 * 1vmin); background: #523127; } .ground { width: 100%; height: calc(8 * 1vmin); background: linear-gradient(#938fa0, #938fa0 2vmin, #484551 2vmin); }"},{"title":"","date":"2022-04-05T13:44:25.604Z","updated":"2022-04-05T13:44:25.604Z","comments":true,"path":"self/pojoaque.css","permalink":"http://dayswithvenki.top/self/pojoaque.css","excerpt":"","text":"/* Pojoaque Style by Jason Tate http://web-cms-designs.com/ftopict-10-pojoaque-style-for-highlight-js-code-highlighter.html Based on Solarized Style from http://ethanschoonover.com/solarized */ :root { --hl-color: #FCE8C3; --hl-bg: white; --hltools-bg: teal; --hltools-color: #ffb03b; --hlnumber-bg: transparent; --hlnumber-color: #468966;; --hlscrollbar-bg: white; --hlexpand-bg: white; } #article-container figure.highlight .hljs { color: #ffb03b; background: white; } .hljs-comment, .hljs-quote { color: #586e75; font-style: italic; } .hljs-keyword, .hljs-selector-tag, .hljs-literal, .hljs-addition { color: #b64926; } .hljs-number, .hljs-string, .hljs-doctag, .hljs-regexp { color: #468966; } .hljs-title, .hljs-section, .hljs-built_in, .hljs-name { color: #ffb03b; } .hljs-variable, .hljs-template-variable, .hljs-title.class_, .hljs-class .hljs-title, .hljs-type, .hljs-tag { color: #b58900; } .hljs-attribute { color: #b89859; } .hljs-symbol, .hljs-bullet, .hljs-link, .hljs-subst, .hljs-meta { color: #cb4b16; } .hljs-deletion { color: #dc322f; } .hljs-selector-id, .hljs-selector-class { color: #d3a60c; } .hljs-formula { background: #073642; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }"},{"title":"","date":"2022-04-05T13:11:41.993Z","updated":"2022-04-05T13:11:41.993Z","comments":true,"path":"self/srcery.css","permalink":"http://dayswithvenki.top/self/srcery.css","excerpt":"","text":"/* Theme: Srcery Description: Srcery dark color scheme for highlight.js Author: Chen Bin Maintainer: @redguardtoo Website: https://srcery-colors.github.io/ Date: 2021-04-13 */ :root { --hl-color: #FCE8C3; --hl-bg: #1C1B19; } #article-container figure.highlight .hljs { background: #1C1B19; /* Black */ color: #FCE8C3; /* Bright White */ } /* Bright White */ .hljs-subst, .hljs-quote, .hljs-literal { color: #FCE8C3; } /* Bright Blue */ .hljs-type, .hljs-symbol { color: #68A8E4; } /* Red */ .hljs-keyword, .hljs-deletion { color: #EF2F27; } /* Yellow */ .hljs-name, .hljs-function, .hljs-attribute, .hljs-selector-attr, .hljs-selector-id, .hljs-selector-class, .hljs-selector-pseudo, .hljs-section, .hljs-title { color: #FBB829; } /* Cyan */ .hljs-code, .hljs-variable, .hljs-property, .hljs-template-variable, .hljs-class { color: #0AAEB3; } /* Bright Green */ .hljs-string, .hljs-regexp, .hljs-bullet, .hljs-addition { color: #98BC37; } /* Bright Magenta */ .hljs-built_in, .hljs-params { color: #FF5C8F; } /* Blue */ .hljs-template-tag, .hljs-selector-tag { color: #2C78BF; } /* Bright Black */ .hljs-link, .hljs-number, .hljs-comment, .hljs-meta { color: #918175; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; } /* @see https://github.com/srcery-colors/srcery-emacs for reference */"},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2022-07-06T03:01:27.942Z","comments":false,"path":"tags/index.html","permalink":"http://dayswithvenki.top/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-03-01T15:02:07.711Z","updated":"2021-10-14T02:13:24.113Z","comments":false,"path":"List/gallery/index.html","permalink":"http://dayswithvenki.top/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 OH MY GIRL 關於OH MY GIRL的圖片"},{"title":"","date":"2022-04-06T15:37:32.000Z","updated":"2022-04-06T15:39:28.286Z","comments":false,"path":"List/movies/index.html","permalink":"http://dayswithvenki.top/List/movies/index.html","excerpt":"","text":"DUO"},{"title":"DUO","date":"2020-04-23T04:58:56.000Z","updated":"2022-03-02T05:32:56.008Z","comments":false,"path":"List/music/index.html","permalink":"http://dayswithvenki.top/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2022-04-05T16:03:34.389Z","updated":"2022-04-05T16:03:34.389Z","comments":true,"path":"Days/days/days.css","permalink":"http://dayswithvenki.top/Days/days/days.css","excerpt":"","text":".wrapper { /*This part is important for centering*/ display: flex; align-items: center; justify-content: center; } .hbe-button{ display: none !important; } .typing-demo { width: 25ch; animation: typing 6s steps(22), blink .5s step-end infinite alternate; white-space: nowrap; overflow: hidden; border-right: 3px solid; font-family: 'xiangsu'; font-size: 10px; } .typing-demo2{ width:50ch; animation:typing 5s steps(22), blink .5s step-end infinite alternate; white-space: nowrap; overflow: hidden; border-right: 3px solid; font-family: 'xiangsu'; font-size: 10px; } cnt{ font-size: 10px !important; } @keyframes typing { from { width: 0 } } @keyframes blink { 50% { border-color: transparent } }"},{"title":"Venki's to do","date":"2022-03-03T16:00:00.000Z","updated":"2022-05-19T02:14:00.951Z","comments":true,"path":"Days/todo/index.html","permalink":"http://dayswithvenki.top/Days/todo/index.html","excerpt":"","text":"三角函数与反三角函数 三角函数与反三角函数的求导公式 与三角函数有关的图像"},{"title":"Kevin's todo","date":"2022-03-04T16:00:00.000Z","updated":"2022-04-06T07:59:55.164Z","comments":true,"path":"Days/do/index.html","permalink":"http://dayswithvenki.top/Days/do/index.html","excerpt":"","text":"Tode List:"},{"title":"","date":"2022-04-02T17:52:11.601Z","updated":"2022-04-02T17:52:11.601Z","comments":true,"path":"codepen/file1/index.html","permalink":"http://dayswithvenki.top/codepen/file1/index.html","excerpt":"","text":"Color Game ​"},{"title":"","date":"2022-04-04T13:00:25.827Z","updated":"2022-04-04T04:59:44.000Z","comments":true,"path":"codepen/dist/style.css","permalink":"http://dayswithvenki.top/codepen/dist/style.css","excerpt":"","text":"*, *:after, *:before { box-sizing: border-box; } html { background: #1A1A1A; font-family: Arial, \"Helvetica Neue\", Helvetica, sans-serif; overflow: hidden; color: #1A1A1A; } html:after, html:before { content: '404'; position: absolute; font-size: 100px; left: 0; right: 0; text-align: center; bottom: 340px; font-weight: 600; z-index: 200; } html:before { content: 'Page Not Found'; font-size: 22px; font-weight: 400; bottom: 330px; } head { display: block; width: 35px; height: 140px; background: #646464; border-bottom: 10px solid #333; margin: auto; transform-origin: 50% 100%; -webkit-animation: 5s find linear infinite; animation: 5s find linear infinite; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; position: absolute; left: 0; right: 0; bottom: -5px; } head:after { content: ''; position: absolute; border-style: solid; border-width: 25px 25px 0 25px; border-color: #333 transparent transparent transparent; width: 85px; left: -25px; top: 0; box-shadow: 0px -10px 0 #FEAF33; } head:before { content: ''; position: absolute; width: 8px; height: 15px; background: #FEAF33; left: 0; right: 0; margin: auto; top: 40px; border-radius: 6px; box-shadow: 0px 0 1px 2px #333; } meta { display: block; width: 250px; height: 200px; background: #FFFEE2; border-radius: 50%; position: absolute; left: -107px; bottom: 270px; margin: auto; text-align: center; color: #333; font-size: 90px; line-height: 200px; font-weight: 600; } meta:after { content: ''; position: absolute; border-style: solid; border-width: 190px 75px 0 75px; border-color: rgba(255, 254, 226, 0.3) transparent transparent transparent; width: 230px; left: 10px; top: 100%; transform: translateY(-60px); } @-webkit-keyframes find { 25% { transform: rotate(25deg); } 0% , 50% , 100% { transform: rotate(0deg); } 75% { transform: rotate(-25deg); } } @keyframes find { 25% { transform: rotate(25deg); } 0% , 50% , 100% { transform: rotate(0deg); } 75% { transform: rotate(-25deg); } }"},{"title":"C++","date":"2022-03-03T16:00:00.000Z","updated":"2022-03-05T09:36:14.792Z","comments":false,"path":"todo/c++/index.html","permalink":"http://dayswithvenki.top/todo/c++/index.html","excerpt":"","text":"Online-CPP-Compiler C++在线编译器"},{"title":"","date":"2022-04-04T13:00:29.545Z","updated":"2022-04-04T04:59:44.000Z","comments":true,"path":"codepen/dist/index.html","permalink":"http://dayswithvenki.top/codepen/dist/index.html","excerpt":"","text":""},{"title":"Python","date":"2022-03-03T16:00:00.000Z","updated":"2022-03-05T09:36:36.407Z","comments":false,"path":"todo/python/index.html","permalink":"http://dayswithvenki.top/todo/python/index.html","excerpt":"","text":"Online-Python-Compiler Python在线编译器"},{"title":"JAVA","date":"2022-03-03T16:00:00.000Z","updated":"2022-03-05T12:49:41.819Z","comments":false,"path":"todo/java/index.html","permalink":"http://dayswithvenki.top/todo/java/index.html","excerpt":"","text":"Online-Java-Compiler JAVA在线编译器 仅支持输入输出，不支持修改代码。"},{"title":"嘉然","date":"2022-03-29T16:00:00.000Z","updated":"2022-05-19T02:14:00.895Z","comments":false,"path":"todo/嘉然/index.html","permalink":"http://dayswithvenki.top/todo/%E5%98%89%E7%84%B6/index.html","excerpt":"","text":"嘉然&amp;向晚—— for ZZM"},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2022-05-19T02:14:00.951Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"http://dayswithvenki.top/List/gallery/wallpaper/index.html","excerpt":"","text":""}],"posts":[{"title":"GoLang学习记录","slug":"GoLang学习记录1","date":"2023-04-05T12:32:21.105Z","updated":"2023-04-05T12:45:59.879Z","comments":false,"path":"posts/golang-1.html","link":"","permalink":"http://dayswithvenki.top/posts/golang-1.html","excerpt":"","text":"labelGo语言中支持label语法：分别是break label，goto label与continue label。 ==break与其他语言类似，但是不和switch搭配使用，goto与continue没有很大区别== 123456789101112func main() { label: for i := 1; i &lt;= 10; i++ { for j := 1; j &lt;= 5; j++ { if i == 8 &amp;&amp; j == 4 { break label } fmt.Print(\"+\") } fmt.Print(\"\\n\") }} 函数标准函数 void 不返回 123func getSum(n1 int, n2 int) { fmt.Println(n1 + n2)} 返回特定类型 123func getSum(n1 int, n2 int) int { return n1 + n2} 多个返回值 普通 12345func getSum(n1, n2 int) (int, int) { sum := n1 + n2 mult := n1 * n2 return sum, mult} 返回值命名 12345func getSum(n1, n2 int) (sum, mult int) { sum = n1 + n2 mult = n1 * n2 return} 匿名函数 ==额外：指针修改值的问题== 函数数据类型 12345678910func getSum(n1, n2 int) (sum, mult int) { sum = n1 + n2 mult = n1 * n2 return}func main() { fmt.Printf(\"type is %T\", getRes) // type is func(int, int) (int, int)} 匿名函数 声明变量的形式声明函数 ==这里与JS箭头函数()=&gt;{}类似== 1234567var getRes = func(n1, n2 int) (sum, mult int) { sum = n1 + n2 mult = n1 * n2 return}a, b := getRes(1, 2)fmt.Println(a, b) 匿名函数立即执行 123456a, b := func(n1, n2 int) (sum, mult int) { sum = n1 + n2 mult = n1 * n2 return}(1, 2)fmt.Println(a, b) defer函数 与JS异步函数的执行（EventLoop）不同，在JS中分为宏任务队列与微任务队列，遇到Promise.then、Object.observe…将会将其push到当前宏任务的微任务队列中，遇到setTimeout、setInterval…将会push到宏任务队列中。 当前宏任务结束后，将处理当前宏任务的微任务队列中的任务； 当前宏任务的微任务队列全部完成后，将处理宏任务队列中的下一个宏任务。 在Go中，defer函数是进行==压栈==处理，即按顺序的第一个defer函数将在最后进行。（类似于宏任务与微任务==栈==） 1234567891011121314151617func deferFunc1() { fmt.Println(1)}func deferFunc2() { fmt.Println(2)}func main() { defer deferFunc1() defer deferFunc2() fmt.Println(3)}// 3// 2// 1 init函数 说明 init函数先于main函数自动执行 每个包中可以有多个init函数，每个包中的源文件中也可以有多个init函数 init函数没有输入参数、返回值，也未声明，所以无法引用 不同包的init函数按照包导入的依赖关系决定执行顺序 无论包被导入多少次，init函数只会被调用一次，也就是只执行一次 init函数在代码中不能被显示的调用，不能被引用（赋值给函数变量），否则会出现编译错误 Go程序仅仅想要用一个package的init执行，我们可以这样使用：import _ “test_xxxx”，导入包的时候加上下划线就ok了 init函数不应该依赖任何在main函数里创建的变量，因为init函数的执行是在main函数之前的 init执行顺序： 单个源文件： init 函数执行顺序与其定义顺序一致，从上到下。 单个package：根据文件名的 字典序 来确定。 main引入多个package： 不存在依赖：对于不同的包，如果不相互依赖的话，按照 main 包中导入顺序调用包的 init 函数，最后再调用 main 包的 init 函数。 存在依赖：如果 package 存在依赖，不同包的 init 函数按照包导入的依赖关系决定执行顺序。 调用顺序为最后被依赖的最先被初始化，如导入顺序 main &gt; a &gt; b &gt; c，则初始化顺序为 c &gt; b &gt; a &gt; main，依次执行对应的 init 方法。","categories":[],"tags":[{"name":"🐱‍💻GoLang","slug":"🐱‍💻GoLang","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B1%E2%80%8D%F0%9F%92%BBGoLang/"}]},{"title":"LeetCode刷题笔记7","slug":"LeetCode Day7","date":"2023-01-06T16:00:00.000Z","updated":"2023-04-08T04:14:24.389Z","comments":false,"path":"posts/51ed13e5.html","link":"","permalink":"http://dayswithvenki.top/posts/51ed13e5.html","excerpt":"","text":"LeetCode 剑指Offer剑指 Offer 27. 二叉树的镜像题目描述​ 请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： ​ 4 / \\ 2 7 / \\ / \\1 3 6 9镜像输出： ​ 4 / \\ 7 2 / \\ / \\9 6 3 1 实例： 12输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 提示 0 &lt;= 节点个数 &lt;= 1000 解题思路​ 递归，对于每个节点来说，树的镜像只是相当于将当前节点的左右子树翻转。 实现代码1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def mirrorTree(self, root: TreeNode) -&gt; TreeNode: if not root: return root temp = root.left root.left = root.right root.right = temp self.mirrorTree(root.left) self.mirrorTree(root.right) return root 剑指 Offer 28. 对称的二叉树题目描述​ 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 ​ 1 / \\ 2 2 / \\ / \\3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: ​ 1 / \\ 2 2 \\ \\ 3 3 实例： 12345输入：root = [1,2,2,3,4,4,3]输出：true输入：root = [1,2,2,null,3,null,3]输出：false 提示 0 &lt;= 节点个数 &lt;= 1000 解题思路 对于任意两个节点L,R来说： L.val == R.val; L.left.val == R.right.val; L.right.val == R.left.val 因此可以进行递归，递归结束的条件： L与R同时越过叶子节点为空，此时return True; L与R只有一个越过，说明不对称，return False; L与R的val不等，return False 实现代码12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: def recur(L,R): if not L and not R: return True if not L or not R or L.val!=R.val: return False return recur(L.left,R.right) and recur(L.right,R.left) return recur(root.left, root.right) if root else True 剑指 Offer 26. 树的子结构题目描述​ 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A: ​ 3 ​ / \\ 4 5 / \\ 1 2给定的树 B： 4 / 1返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 实例 12345678示例 1：输入：A = [1,2,3], B = [3,1]输出：false示例 2：输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制 0 &lt;= 节点个数 &lt;= 10000 解题思路 先序遍历A，找到值与B根节点相同的节点 以找到的节点为根节点与B节点作对比判断树的结构是否相等 结构不等的话重新找下一端点 实现代码123456789101112class Solution: def isSubStructure(self, A: TreeNode, B: TreeNode) -&gt; bool: if not A or not B: return False return self.compare(A,B) or self.isSubStructure(A.left,B) or self.isSubStructure(A.right,B) def compare(self, A:TreeNode, B:TreeNode): if not B: return True if not A: return False return A.val == B.val and self.compare(A.left, B.left) and self.compare(A.right, B.right) ​","categories":[],"tags":[{"name":"🐲LeetCode","slug":"🐲LeetCode","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B2LeetCode/"}]},{"title":"LeetCode刷题笔记6","slug":"LeetCode Day6","date":"2023-01-05T16:00:00.000Z","updated":"2023-04-08T04:14:16.333Z","comments":false,"path":"posts/51ed13e5.html","link":"","permalink":"http://dayswithvenki.top/posts/51ed13e5.html","excerpt":"","text":"二叉树的遍历==首先，先复习一下二叉树的遍历：== 样例二叉树图 前序遍历 代码实现 递归 实现代码 12345678910def preorderTraversal(root: Optional[TreeNode]) -&gt; List[int]: ans = [] def preOrder(node: Optional[TreeNode]): if not node: return [] ans.append(node) preOrder(node.left) preOrder(node.right) preOrder(root) return ans 迭代 思路：使用栈辅助实现非递归。 由于前序遍历是先对当前节点进行操作，再遍历当前节点的左子树，最后遍历当前节点的右子树。 因此在==入栈前进行操作==，随后遍历其左子树——即==栈中的点左子树已经被遍历==，当左子树遍历到底的时候，将栈顶pop出来，此时的栈顶元素的左子树已经遍历完毕，开始遍历其右子树，即==出栈遍历右子树==。 实现代码： Python 1234567891011def preorderTraversal(root: Optional[TreeNode]) -&gt; List[int]: ans, stack = [], [] cur = root while cur or stack: while cur: ans.append(cur.val) stack.append(cur) cur = cur.left cur = stack.pop() cur = cur.right return ans Typescript 123456789101112131415function preorderTraversal(root: TreeNode | null): number[] { const ans = &lt;number[]&gt;[]; const stack = &lt;TreeNode[]&gt;[]; let cur = root; while(cur || stack.length) { while(cur) { ans.push(cur.val); stack.push(cur); cur = cur.left; } cur = stack.pop(); cur = cur.right; } return ans;} 中序遍历 代码实现 递归 实现代码 12345678910def inorderTraversal(root: Optional[TreeNode]) -&gt; List[int]: ans = [] def inOrder(node: Optional[TreeNode]): if not node: return [] inOrder(node.left) ans.append(node) inOrder(node.right) inOrder(root) return ans 迭代 思路：使用栈辅助实现非递归，与前序遍历非递归十分类似。 由于中序遍历是先对当前节点的左子树进行操作，再对当前节点进行操作，最后遍历当前节点的右子树。 因此先进行入栈操作，遍历其左子树——即==栈中的点左子树已经被遍历==，当左子树遍历到底的时候，将栈顶pop出来，==出栈后进行操作==，随后，此时的栈顶元素的左子树已经遍历完毕，开始遍历其右子树，即==操作后遍历右子树==。 实现代码： Python 1234567891011def preorderTraversal(root: Optional[TreeNode]) -&gt; List[int]: ans, stack = [], [] cur = root while cur or stack: while cur: stack.append(cur) cur = cur.left cur = stack.pop() ans.append(cur.val) cur = cur.right return ans Typescript 123456789101112131415function preorderTraversal(root: TreeNode | null): number[] { const ans = &lt;number[]&gt;[]; const stack = &lt;TreeNode[]&gt;[]; let cur = root; while(cur || stack.length) { while(cur) { stack.push(cur); cur = cur.left; } cur = stack.pop(); ans.push(cur.val); cur = cur.right; } return ans;} 后序遍历 代码实现 递归 实现代码 12345678910def inorderTraversal(root: Optional[TreeNode]) -&gt; List[int]: ans = [] def inOrder(node: Optional[TreeNode]): if not node: return [] inOrder(node.left) inOrder(node.right) ans.append(node) inOrder(root) return ans 迭代 思路：使用栈辅助实现非递归，与前中序遍历左子树的思路一致，但是在于出栈的时候需要判断是否含有右子树以及右子树是否已经被遍历。 由于中序遍历是先对当前节点的左子树进行操作，再遍历当前节点的右子树，最后对当前节点进行操作。 因此先进行入栈操作，遍历其左子树——即==栈中的点左子树已经被遍历==，当左子树遍历到底的时候，将栈顶pop出来时： ​ 首先判断该节点是否==还有右子树或者右子树是否已经被完全遍历==， ​ 若是，则对该节点进行操作； ​ 否则，将该节点==重新入栈==。 Python 1234567891011121314151617def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]: ans, stack = [], [] cur = root prev = None # 用于保存上一个被遍历右子树的节点 while cur or stack: while cur: stack.append(cur) cur = cur.left cur = stack.pop() if not cur.right or cur.right == prev: ans.append(cur.val) prev = cur cur = None else: stack.append(cur) cur = cur.right return ans Typescript 123456789101112131415161718192021222324function postorderTraversal(root: TreeNode | null): number[] { const stack = &lt;TreeNode[]&gt;[]; const ans = &lt;number[]&gt;[]; let prev = undefined; while(root || stack.length) { while(root){ stack.push(root); root = root.left; } root = stack.pop(); if(!root.right || root.right === prev) { ans.push(root.val); prev = root; root = undefined; } else { stack.push(root); root = root.right; } } return ans;}; LeetCode 剑指Offer剑指 Offer 32 - I. 从上到下打印二叉树（层次遍历） 题目描述从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 代码实现 迭代 思路：用队列作为辅助空间，队列初始化为[root]，每次出队的时候，对出队的节点进行操作，然后将出队的节点的子节点一同入队（若有），循环直至队列为空。 Python 123456789101112def levelOrder(root: TreeNode) -&gt; List[int]: if not root: return [] ans, queue = [], [root] while queue: cur = queue.pop(0) ans.append(cur.val) if cur.left: queue.push(cur.left) if cur.right: queue.push(cur.right) return ans Typescript 123456789101112131415function levelOrder(root: TreeNode | null): number[] { if(!root){ return [] } const ans = &lt;number[]&gt;[]; const queue = &lt;TreeNode[]&gt;[root]; while(queue.length) { let cur = queue.shift(); ans.push(cur.val); if(cur.left) queue.push(cur.left); if(cur.right) queue.push(cur.right); } 剑指 Offer 32 - II. 从上到下打印二叉树 II题目描述​ 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 实例 123456789101112131415例如:给定二叉树:&nbsp;[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7返回其层次遍历结果：[ [3], [9,20], [15,7]] 提示 节点总数 &lt;= 1000 解题思路​ 事实上还是二叉树的层次遍历，与直接存储节点的值稍微不一样的地方在于，需要按不同层次进行分类。 具体思路为以下几点： 队列中存储的值不仅是节点的值，同时将节点的层次一并存储； 而返回的ans不单纯是一个List而是一个==哈希表(字典)==，以下标作为key，节点的值作为value； 由于每次进行出队操作，都需要添加出队节点的左子树与右子树（若存在），所以新节点入队时候将额外带上出队的层次+1； 最后出队的值会判断是否存在当前层次的value，若没有则ans当前层次初始化一个，若有则ans[当前层次].append()。 实现代码 Python 123456789101112131415161718192021class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] ans, queue = [], [[root, 0]] while queue: item = queue.pop(0) cur = item[0] pos = item[1] if cur.left: queue.append([cur.left, pos + 1]) if cur.right: queue.append([cur.right, pos + 1]) if len(ans) &lt;= pos: ans.append([cur.val]) else: ans[pos].append(cur.val) return ans JS/TS 12345678910111213141516171819202122232425262728function levelOrder(root: TreeNode | null): number[][] { if(!root) return [] const ans = &lt;number[][]&gt;[]; const queue = [[root, 0]]; while(queue.length) { let item = queue.shift(); let cur = &lt;TreeNode&gt;item[0]; let pos = &lt;number&gt;item[1]; if(cur.left){ queue.push([cur.left, pos+1]); } if(cur.right){ queue.push([cur.right, pos+1]); } if(ans.length&lt;=pos){ ans.push([cur.val]); } else{ ans[pos].push(cur.val); } } return ans; }; 剑指 Offer 32 - III. 从上到下打印二叉树 III题目描述​ 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 实例 123456789101112131415例如:给定二叉树:&nbsp;[3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7返回其层次遍历结果：[ [3], [20,9], [15,7]] 提示 节点总数 &lt;= 1000 解题思路​ 步骤与第二题几乎完全一致，最后对ans进行一个简单的处理，倒转所有下标为奇数的列表即可。 实现代码 Python 12345678910111213141516171819202122232425class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: if not root: return [] ans, queue = [], [[root, 0]] while queue: item = queue.pop(0) cur = item[0] pos = item[1] if cur.left: queue.append([cur.left, pos + 1]) if cur.right: queue.append([cur.right, pos + 1]) if len(ans) &lt;= pos: ans.append([cur.val]) else: ans[pos].append(cur.val) for index, a in enumerate(ans): if index%2: a.reverse() return ans Typescript 12345678910111213141516171819202122232425262728293031323334function levelOrder(root: TreeNode | null): number[][] { if(!root) return [] const ans = &lt;number[][]&gt;[]; const queue = [[root, 0]]; while(queue.length) { let item = queue.shift(); let cur = &lt;TreeNode&gt;item[0]; let pos = &lt;number&gt;item[1]; if(cur.left){ queue.push([cur.left, pos+1]); } if(cur.right){ queue.push([cur.right, pos+1]); } if(ans.length&lt;=pos){ ans.push([cur.val]); } else{ ans[pos].push(cur.val); } } for(let [index,value] of ans.entries()){ if(index%2){ value.reverse(); } } return ans; };","categories":[],"tags":[{"name":"🐲LeetCode","slug":"🐲LeetCode","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B2LeetCode/"}]},{"title":"LeetCode刷题笔记5","slug":"LeetCode Day5","date":"2023-01-04T16:00:00.000Z","updated":"2023-04-08T04:14:08.228Z","comments":false,"path":"posts/c8e4425f.html","link":"","permalink":"http://dayswithvenki.top/posts/c8e4425f.html","excerpt":"","text":"LeetCode 剑指Offer剑指 Offer 04. 二维数组中的查找题目描述​ 在一个n * m的二维数组中，每一行都按照从左到右 非递减 的顺序排序，每一列都按照从上到下 非递减 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 实例： 1234567891011现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target&nbsp;=&nbsp;5，返回&nbsp;true。给定&nbsp;target&nbsp;=&nbsp;20，返回&nbsp;false。 提示 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 解题思路 解题思路: 直接遍历 —— 时间复杂度O(nm)， 空间复杂度O(1)； 每行二分查找 —— 时间复杂度O(nlogm)， 空间复杂度O(1)； Z字查找/二叉排序树 —— 时间复杂度O(n+m)， 空间复杂度O(1)。 二叉排序树构建过程，将第一行的最后一列作为二叉树的根节点。 ​ 此时，树的左孩子永远比父节点小，右孩子会比父节点大。 ​ 遍历过程中，若当前节点的值小于目标值target，则遍历该节点的右孩子；当大于target则遍历左孩子，若相等则返回True。当i&lt;0或j&gt;=len(matrix)时仍未找到，说明不存在target，返回False。 ​ 由于是将数组视为二叉树，所以当i--的时候，相当于遍历左子树，当j++时遍历右子树。 实现代码12345678910111213141516171819202122232425262728293031323334class Solution: def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -&gt; bool: # 直接遍历 O(nm) O(1) # for row in matrix: # for item in row: # if item == target: # return True # return False # 二分查找 O(nlogm) O(1) # for row in matrix: # left, right = 0, len(row) - 1 # while left &lt;= right: # mid = (left + right) // 2 # if row[mid] == target: # return True # elif row[mid] &lt; target: # left = mid + 1 # else: # right = mid - 1 # return False # 搜索二叉树/Z字查找 O(m+n) O(1) if len(matrix) == 0: return False root_i, root_j = len(matrix[0])-1,0 while root_i&gt;=0 and root_j&lt;= len(matrix)-1: if matrix[root_j][root_i] == target: return True elif matrix[root_j][root_i] &lt; target: root_j += 1 else: root_i -= 1 return False 剑指 Offer 11. 旋转数组的最小数字（简单)154. 寻找旋转排序数组中的最小值 II(困难)题目描述​ 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 ​ 给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。 ​ 注意，数组[a[0], a[1], a[2], ..., a[n-1]]旋转一次 的结果为数组[a[n-1], a[0], a[1], a[2], ..., a[n-2]]。 示例 12345输入：numbers = [3,4,5,1,2]输出：1输入：numbers = [2,2,2,0,1]输出：0 提示 n == numbers.length 1 &lt;= n &lt;= 5000 -5000 &lt;= numbers[i] &lt;= 5000 numbers 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 解题思路 调用API….. min,sorted…[当然不给用] 时间复杂度O(n) 二分查找 时间复杂度O(logn) 使用左右指针l,r记录首位位置，m为中间位置。 最小值一定在右排序数组中。 当nums[m]&lt;nums[r]，说明此时m一定是在右排序数组中，因此l = m + 1，在m的右边继续搜索； 当nums[m]&gt;nums[r]，说明此时m一定在左排序数组中，因此r = m, 在m的左边搜索； 当nums[m]==nums[r]，无法判断m在哪一边，但是此时可以缩小数组的范围，令r = r - 1，此操作可能导致旋转点被去除，但是去除旋转点同时可以理解为在一个没有进行旋转的数组进行搜索，所以r=r-1操作可行。 ==为什么不能与左侧端点l进行比较呢？== ​ 原因在于： r的初始位置一定是在右排序数组中，而l的初始位置无法确定在哪个排序数组中 代码实现1234567891011121314151617181920class Solution: def minArray(self, numbers: List[int]) -&gt; int: # 排序返回第一个 # numbers = sorted(numbers) # return numbers[0] # ...min # return min(numbers) # 二分 l,r = 0, len(numbers)-1 while l&lt;r: m = (l + r) // 2 if numbers[m] &gt; numbers[r]: l = m + 1 elif numbers[m] == numbers[r]: r = r - 1 else: # 小于 r = m return numbers[l] 剑指 Offer 50. 第一个只出现一次的字符题目描述​ 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 示例 12345输入：s = \"abaccdeff\"输出：'b'输入：s = \"\" 输出：' ' 提示 0 &lt;= s 的长度 &lt;= 50000 解题思路 hash map 代码实现1234567891011121314151617181920212223242526272829class Solution: def firstUniqChar(self, s: str) -&gt; str: # if not len(s): # return \" \" # hashmap = {} # for c in s: # if c not in hashmap: # hashmap[c] = 1 # else: # hashmap[c] = -1 # for key, val in hashmap.items(): # if val == 1: # return key # return \" \" # 优化 # 不存出现的频次而是存True or False if not len(s): return \" \" hashmap = {} for c in s: if c not in hashmap: hashmap[c] = True else: hashmap[c] = False for key, val in hashmap.items(): if val: return key return \" \"","categories":[],"tags":[{"name":"🐲LeetCode","slug":"🐲LeetCode","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B2LeetCode/"}]},{"title":"LeetCode刷题笔记4","slug":"LeetCode Day4","date":"2023-01-03T16:00:00.000Z","updated":"2023-04-08T04:13:59.521Z","comments":false,"path":"posts/bfe372c9.html","link":"","permalink":"http://dayswithvenki.top/posts/bfe372c9.html","excerpt":"","text":"LeetCode 剑指Offer剑指 Offer 03. 数组中重复的数字题目描述​ 找出数组中重复的数字。 ​ 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 实例： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 提示 2 &lt;= n &lt;= 100000 解题思路 解题思路: 使用辅助空间，哈希表； 交换位置，以数组本身作为哈希表。 实现代码123456789101112131415161718192021# 哈希表class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: dic = {} for num in nums: if num not in dic: dic[num] = 1 else: return num # 交换位置class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: i = 0 while i &lt; len(nums): if i == nums[i]: i += 1 continue if nums[nums[i]] == nums[i]: return nums[i] nums[nums[i]],nums[i] = nums[i], nums[nums[i]] 剑指 Offer 53 - I. 在排序数组中查找数字 I题目描述​ 统计一个数字在排序数组中出现的次数。 实例 12345输入: nums = [5,7,7,8,8,10], target = 8输出: 2 输入: nums = [5,7,7,8,8,10], target = 6输出: 0 提示 0 &lt;= nums.length &lt;= 10^5 -10^9 &lt;= nums[i] &lt;= 10^9 nums是一个非递减数组 -10^9 &lt;= target &lt;= 10^9 解题思路 哈希表/遍历计数 双指针中间逼近 二分法 其中 二分法为双指针法的优化，从O(n/2)=&gt; O(logn) 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution: def search(self, nums: List[int], target: int) -&gt; int: # 解法1 hash = {} for num in nums: if num not in hash: hash[num] = 1 else: hash[num] += 1 return hash.get(target, 0) # 解法2 sum = 0 for num in nums: if num == target: sum += 1 return sum # 解法3 双指针法 left, right = 0, len(nums) - 1 while left &lt;= right: if nums[left] &gt; target or nums[right] &lt; target: return 0 if nums[left] &lt; target: left += 1 if nums[right] &gt; target: right -= 1 if nums[left] == target and nums[right] == target: return right - left + 1 return 0 # 解法4 二分法 # 搜索右边界 right i, j = 0, len(nums) - 1 while i &lt;= j: m = (i + j) // 2 if nums[m] &lt;= target: i = m + 1 else: j = m - 1 right = i if j &gt;= 0 and nums[j] != target: return 0 # 搜索左边界 left i = 0 while i &lt;= j: m = (i + j) // 2 if nums[m] &lt; target: i = m + 1 else: j = m - 1 left = j return right - left - 1 剑指 Offer 53 - II. 0～n-1中缺失的数字题目描述​ 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 12345输入: [0,1,3]输出: 2 输入: [0,1,2,3,4,5,6,7,9]输出: 8 限制 1 &lt;= 数组长度 &lt;= 10000 解题思路1. 数学求和... 2. 双指针 3. 二分法: 找中值，如果中值的下标位置，`index == value`。说明中值前的值没问题，到中值后面的找，否则，到中值前找。 代码实现12345678910111213141516171819202122232425262728class Solution: def missingNumber(self, nums: List[int]) -&gt; int: # 数学求和 等差数列，首项为0，公差为1，项数为len(nums)+1 return len(nums)*(len(nums)+1)//2 - sum(nums) # 双指针 left, right = 0, len(nums)-1 if nums[0] != 0: return 0 if nums[-1] != len(nums): return len(nums) while left &lt; right: if nums[left+1] - nums[left] != 1: return nums[left] + 1 elif nums[right] - nums[right-1] != 1: return nums[right-1] + 1 left,right = left + 1, right -1 # 二分法 l, r = 0, len(nums) - 1 while l &lt;= r: m = (l + r) // 2 if nums[m] == m: l = m + 1 else: r = m - 1 return l","categories":[],"tags":[{"name":"🐲LeetCode","slug":"🐲LeetCode","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B2LeetCode/"}]},{"title":"LeetCode刷题笔记3","slug":"LeetCode Day3","date":"2023-01-02T16:00:00.000Z","updated":"2023-04-08T04:13:52.388Z","comments":false,"path":"posts/2187e76a.html","link":"","permalink":"http://dayswithvenki.top/posts/2187e76a.html","excerpt":"","text":"LeetCode 剑指Offer剑指 Offer 05. 替换空格题目描述​ 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 实例： 12输入：head = [1,3,2]输出：[2,3,1] 限制 0 &lt;= 链表长度 &lt;= 10000 解题思路 解题思路: 申请辅助空间。 调用原生API。 实现代码 Python解法 123456789101112131415161718# 申请辅助空间class Solution: def replaceSpace(self, s: str) -&gt; str: arr = [] for sub in s: if sub == \" \": arr.append('%20') else: arr.append(sub) res = '' for item in arr: res += item return res# 调用原生APIclass Solution: def replaceSpace(self, s: str) -&gt; str: return s.replace(\" \", \"%20\") JS/TS解法 12345// 调用原生API replace// JS/TS Replace 与 Python Replace不同，JS Replace只替换第一个，需要用正则表达式。function replaceSpace(s: string): string { return s.replace(/\\s/g, \"%20\");}; 剑指 Offer 58 - II. 左旋转字符串题目描述​ 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab” 实例： 12345输入: s = \"abcdefg\", k = 2输出: \"cdefgab\" 输入: s = \"lrloseumgh\", k = 6输出: \"umghlrlose\" 限制 1 &lt;= k &lt; s.length &lt;= 10000 解题思路 解题思路: 切片/调用原生API； 若不允许切片则创建辅助空间。 实现代码 Python解法 123456789101112131415# 切片class Solution: def reverseLeftWords(self, s: str, n: int) -&gt; str: return s[n:] + s[:n] # 创建辅助空间class Solution: def reverseLeftWords(self, s:str, n: int) -&gt; str: pre,post = \"\",\"\" for i in range(len(s)): if i &lt; n: post += s[i] else: pre += s[i] return pre + post Js/Ts解法 1234function reverseLeftWords(s: string, n: number): string { // return s.substring(n,s.length) + s.substr(0,n); return s.slice(n, s.length) + s.slice(0, n);}; 🔥 LeetCode 热题 HOT 10020. 有效的括号题目描述​ 给定一个只包括 '('，')'，'{'，'}'，'['，']'的字符串s ，判断字符串是否有效。 ​ 有效字符串需满足： ​ 1. 左括号必须用相同类型的右括号闭合。​ 2. 左括号必须以正确的顺序闭合。​ 3. 每个右括号都有一个对应的相同类型的左括号 实例 12345678输入：s = \"()\"输出：true输入：s = \"()[]{}\"输出：true输入：s = \"(]\"输出：false 提示 1 &lt;= s.length &lt;= 104 s 仅由括号 '()[]{}' 组成 解题思路 解题思路 使用辅助栈，字符串长度为奇数则False，否则遍历字符串，当前为左括号的时候入栈，当右括号时，判断栈顶元素是否匹配括号，匹配则pop栈顶元素，否则，return False；最后判断栈是否还存有元素(即是否有左括号尚未被匹配)，有则False。 实现代码1234567891011121314151617181920class Solution: def isValid(self, s: str) -&gt; bool: if len(s)%2: return False stack = [] left = ['(', '{', '['] for sub in s: if sub in left: stack.append(sub) continue elif not len(stack): return False if sub == ')' and stack[-1] != '(': return False if sub == ']' and stack[-1] != '[': return False if sub == '}' and stack[-1] != '{': return False stack.pop() return not len(stack)","categories":[],"tags":[{"name":"🐲LeetCode","slug":"🐲LeetCode","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B2LeetCode/"}]},{"title":"LeetCode刷题笔记2","slug":"LeetCode Day2","date":"2023-01-01T16:00:00.000Z","updated":"2023-04-08T04:13:45.675Z","comments":false,"path":"posts/5680d7fc.html","link":"","permalink":"http://dayswithvenki.top/posts/5680d7fc.html","excerpt":"","text":"LeetCode 剑指Offer剑指 Offer 05. 替换空格题目描述​ 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 实例： 12输入：s = \"We are happy.\"输出：\"We%20are%20happy.\" 限制 0 &lt;= s 的长度 &lt;= 10000 解题思路 解题思路: 遍历链表压入栈，最后返回依次出栈的数组。 递归遍历链表，遍历到底后压入vector。 实现代码 Python解法 12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reversePrint(self, head: ListNode) -&gt; List[int]: res = [] while head: res.append(head.val) head = head.next return res[::-1] C++解法 1234567891011121314151617181920/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {vector&lt;int&gt; a;public: vector&lt;int&gt; reversePrint(ListNode* head) { if(!head) return a; reversePrint(head-&gt;next); arr.push_back(head-&gt;val); return a; }}; 剑指 Offer 24. 反转链表题目描述​ 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 实例 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 限制 0 &lt;= 节点个数 &lt;= 5000 解题思路 解题思路: ​ 1. 申请动态扩容容器辅助； ​ 2. 双指针法:每次遍历当前指针cur与上一个指针pre的next互换位置；空间O(1) ​ 3. ==递归==：head-&gt;next-&gt;next = head 递归的终止条件为head==None or head.next==None; cur为最后的返回结果，cur的第一个值为顺序链表的最后一个Node, 即当前head或head.next; head.next.next = next即cur.next = head与双指针类似。 实现代码 C++解法 12345678910111213141516171819202122// 双指针法:/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* reverseList(ListNode* head) { ListNode *cur = head, *pre = nullptr; while(cur != nullptr) { ListNode* temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; } return pre; }}; Python解法 12345678910111213141516171819202122232425262728# 双指针法# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: cur,pre = head,None while cur: temp = cur.next cur.next = pre pre = cur cur = temp return pre # 递归法class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if(head==None or head.next==None): return head cur = self.reverseList(head.next) head.next.next = head head.next = None return cur 剑指 Offer 35. 复杂链表的复制题目描述 题目描述 ​ 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 123456789101112# 实例输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]输入: head = []输出: [] 提示 -10000 &lt;= Node.val &lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 解题思路 解题思路 对链表进行深拷贝。 ==首先看：普通链表的拷贝== 123456789101112131415class Node: def __init__(self, x: int, next: 'Node' = None): self.val = int(x) self.next = next class Solution: def copyList(self, head: 'Node') -&gt; 'Node': cur = head dum = pre = Node(0) while cur: node = Node(cur.val) pre.next = node cur = cur.next pre = node return dum ==本题的链表结构== 1234567891011121314151617class Node: def __init__(self, x:int ,next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random class Solution: def copyRandomList(self, head: 'Node') -&gt; 'Node': cur = head dum = pre = Node(0) while cur: node = Node(cur.val) pre.next = node # pre.random = ??? # 无法获取当前链表的Random节点 cur = cur.next pre = node return dum 因此: hashMap构造法（时间复杂度O(n), 空间复杂度O(n)) 考虑到新链表与旧链表存在一一对应的关系，所以构建原链表-&gt;新链表的映射关系，再遍历原链表来构建新链表的next与random拷贝进新链表中。 拼接+拆分法（时间复杂度O(n), 空间复杂度O(1)) (1) 复制原来的各个节点, 构建拼接链表 (2) 构建新链表各个节点的random指向 (3) 拆分原/新链表 (4) 返回新链表的头节点res即可 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# hashmap法\"\"\"# Definition for a Node.class Node: def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random\"\"\"class Solution: def copyRandomList(self, head: 'Node') -&gt; 'Node': if not head: return hashmap = {} cur = head while cur: hashmap[cur] = Node(cur.val) cur = cur.next cur = head while cur: hashmap[cur].next = hashmap.get(cur.next) hashmap[cur].random = hashmap.get(cur.random) cur = cur.next return hashmap[head] # 拼接/拆分法class Solution: def copyRandomList(self, head: 'Node') -&gt; 'Node': if not head: return cur = head # 复制节点 while cur: temp = Node(cur.val) temp.next = cur.next cur.next = temp cur = temp.next # 拷贝源节点的random给新节点 cur = head while cur: # 判断是否非None if cur.random: # 之所以后半要取random.next而不是random在于需要链接的random为拷贝的新节点，即random.next cur.next.random = cur.random.next cur = cur.next.next # 分离所需新链表, 新链表头节点为head的拷贝节点 res = cur = head.next while cur.next: cur.next = cur.next.next cur = cur.next return res 2023.2.3 今日收获今天的题目属于 链表 的基础数据结构。 ​ 第一、二题都比较简单，根据昨天的经验，可以申请一个辅助容器(栈)来协助所需操作，当然也可以通过递归的方法，先递归到最深的节点，最后再倒序 ​ 第三题的话涉及到一个深拷贝的问题，解决的办法是与简单链表进行对比，查看所需步骤的区别，最后是通过哈希表/拼接拆分法来解决问题。","categories":[],"tags":[{"name":"🐲LeetCode","slug":"🐲LeetCode","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B2LeetCode/"}]},{"title":"LeetCode刷题笔记1","slug":"LeetCode Day1","date":"2022-12-31T16:00:00.000Z","updated":"2023-04-05T12:59:08.895Z","comments":false,"path":"posts/3c79af21.html","link":"","permalink":"http://dayswithvenki.top/posts/3c79af21.html","excerpt":"","text":"LeetCode 剑指Offer剑指 Offer 09. 用两个栈实现队列题目描述​ 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回-1 ) 实例： 12345678910111213# 实例1： # 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[],[]] # 输出： [null,null,3,-1,-1]# 实例2： # 输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] # 输出： [null,-1,null,null,5,2] 提示 1 &lt;= values &lt;= 10000 最多会对appendTail、deleteHead进行10000 次调用 解题思路 对于输入输出样例的解释： ​ 输入上半对应的是操作函数名，下半指的是对应的参数。 比如: [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\",\"deleteHead\"][[],[3],[],[],[]] ​ 则是 CQueue()-&gt;appendTai(3)-&gt;deleteHead()-&gt;deleteHead()-&gt;deleteHead() [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 则是CQueue()-&gt;deleteHead()-&gt;appendTail(5)-&gt;appendTail(2)-&gt;deleteHead()-&gt;deleteHead() 解题思路: 即通过两个栈实现一个队列的操作，由于单独一个栈无法实现出队，因此设栈A负责入队，栈B辅助出队。 入队：直接push入栈A即可。 出队：将栈A栈顶元素依次push入栈B，最后将栈B的顶部元素pop出来，最后将栈B栈顶元素依次push回栈A即可。 实现代码1234567891011121314151617181920212223242526272829303132333435class CQueue {public: stack&lt;int&gt; stackA; stack&lt;int&gt; stackB; CQueue() {} void appendTail(int value) { stackA.push(value); } int deleteHead() { if(stackA.empty()) return -1; while(!stackA.empty()){ int temp = stackA.top(); stackA.pop(); stackB.push(temp); } int res = stackB.top(); stackB.pop(); while(!stackB.empty()){ int temp = stackB.top(); stackB.pop(); stackA.push(temp); } return res; }};/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj-&gt;appendTail(value); * int param_2 = obj-&gt;deleteHead(); */ 剑指 Offer 30. 包含min函数的栈题目描述​ 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 实例： 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.min(); --&gt; 返回 -2. 提示 各函数的调用总次数不超过 20000 次 解题思路​ 实际上和直接手写一个栈的数据结构类似，一般的栈pop与push的时间复杂度是O(1)，而min由于要遍历栈(数组)，因此时间复杂度为O(n)。 ​ 由于本题要求min的时间复杂度也要为O(1)，因此本题可用双栈的方法解决，使其时间复杂度最终也为O(1)。 解题思路： 分为栈A与栈B两个栈： ​ 其中栈A进行正常的pop与push操作，而栈B则push栈A每次进行入栈操作时的最小的数，并且当某个元素从栈Apop后，栈B也要同步进行pop的操作。 ∴ 栈Bpush的逻辑为: 栈B空的时候，push栈Apush的元素x，栈B非空时, push的value需要&lt;=栈B的栈顶元素； ​ pop的逻辑为: 若栈Apop的元素为栈B的栈顶元素时，栈B进行pop操作。 因次栈minstack与栈A栈B的关系为： 1. `minstack.push/pop =&gt; A.push/pop =&gt; 根据条件再决定是否B.push/pop` 2. `minstack.top() == A.top()` 3. `minstack.min() == B.top()` 实现代码12345678910111213141516171819202122232425262728293031class MinStack: def __init__(self): \"\"\" initialize your data structure here. \"\"\" self.stackA, self.stackB = [],[] def push(self, x: int) -&gt; None: self.stackA.append(x) if not self.stackB or self.stackB[-1] &gt;= x: self.stackB.append(x) def pop(self) -&gt; None: if self.stackA.pop() == self.stackB[-1]: self.stackB.pop() def top(self) -&gt; int: return self.stackA[-1] def min(self) -&gt; int: return self.stackB[-1]# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.min() 2023.2.2 今日收获今天的题目属于 栈与队列 的基础数据结构。 ​ 第一道题是用栈实现队列的操作，第二道题是用空间换取时间。双栈的结合使用既可以模拟队列，又可以优化单栈操作的时间复杂度。第二道题没有用C++转为使用Python是因为C++定义链表的知识忘了很多… ​ 回头第二题需要用C++链表重新写一遍栈的数据结构定义。 ==补充== ​ …额，突然记起来C++内部其实有Stack的数据结构，这题并不需要用链表再定义Stack这么麻烦，补充C++写法如下： 12345678910111213141516171819202122232425262728293031323334353637383940class MinStack {public: /** initialize your data structure here. */ stack&lt;int&gt; stackA,stackB; MinStack() { } void push(int x) { stackA.push(x); if(stackB.empty() || stackB.top() &gt;= x) stackB.push(x); } void pop() { if(stackA.top()==stackB.top()){ stackA.pop(); stackB.pop(); } else { stackA.pop(); } } int top() { return stackA.top(); } int min() { return stackB.top(); }};/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;min(); */ LeetCode 精选面试题1. 两数之和题目描述​ 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 ​ 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 ​ 你可以按任意顺序返回答案。 实例： 1234567891011121314151617# 实例1# 输入: nums = [2,7,11,15], target = 9# 输出: [0,1] # 实例2# 输入: nums = [3,2,4], target = 6# 输出: [1,2] # 实例3# 输入: nums = [3,3], target = 6# 输出: [0,1] 提示 2 &lt;= nums.length &lt;= 10^4 -10^9 &lt;= nums[i] &lt;= 10^9 -10^9 &lt;= target &lt;= 10^9 只会存在一个有效答案 解题思路​ 利用Python Dict数据类型模拟Hashmap, 其中Hashmap的key为值item，value为下标index，存入Hashmap。 ​ 若遍历时Hashmap存在值为target - 当前遍历的item的key，则返回[index, Hashmap[target-item]]。 实现代码1234567class Solution(object): def addTwo(self, nums, target): Hashmap = {} for index, item in enumerate(nums): if target - item in Hashmap: return [index, Hashmap[target-item]] Hashmap[item] = index","categories":[],"tags":[{"name":"🐲LeetCode","slug":"🐲LeetCode","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B2LeetCode/"}]},{"title":"OS LAB4 实验报告","slug":"OS项目设计-lab4实验报告","date":"2022-10-31T16:00:00.000Z","updated":"2023-04-08T04:31:37.872Z","comments":true,"path":"posts/os-lab4.html","link":"","permalink":"http://dayswithvenki.top/posts/os-lab4.html","excerpt":"","text":"Lab4文件系统0. 实验前：切换至Lab2分支在xv6-labs-2021文件夹下运行终端，并且运行以下命令： 123$ git fetch$ git checkout fs$ make clean 1. 对 xv6 文件系统添加“大文件”的支持1.1 Large files1Modify bmap() so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. You'll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you're not allowed to change the size of an on-disk inode. The first 11 elements of ip-&gt;addrs[] should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when bigfile writes 65803 blocks and usertests runs successfully: 1.1.1 解题过程 修改 kernel/fs.h 中的直接块号的宏定义 NDIRECT 为 11; 修改 inode 相关结构体的块号数组,包括 kernel/fs.h 中的磁盘inode 结构体 struct dinode的 addrs ; kernel/file.h 中的内存inode 结构体 struct inode 的 addrs 将数组大小也改变为 NDIRECT+2, 因为 inode 的块号总数没有改变, 但 NDIRECT 减少了 1; kernel/fs.h添加宏定义二级间接块号总数NDOUBLYINDIRECT，可表示的块号为一级间接块号NINDIRECT的平方; kernel/fs.c中bmap()用于返回inode的相对块号对应的磁盘中的块号，由于 inode 结构中前 NDIRECT 个块号与修改前是一致的, 因此只需要添加对第 NDIRECT 即 13 个块的二级间接索引的处理代码; 修改kernel/fs.c下的itrunc()，函数用于释放inode的数据块; 修改kernel/fs.h中的MAXFILE。 1.1.2 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// kernel/fs.h#define NDIRECT 11#define NDOUBLYINDIRECT (NINDIRECT * NINDIRECT)#define MAXFILE (NDIRECT + NINDIRECT + NDOUBLYINDIRECT)// ...struct dinode { // ... uint addrs[NDIRECT+2];}// kernel/file.hstruct inode { // ... uint addrs[NDIRECT+2]}// kernel/fs.cstatic uintbmap(struct inode *ip, uint bn){ // ... return addr; } bn -= NINDIRECT; if(bn &lt; NDOUBLYINDIRECT) { if((addr = ip-&gt;addrs[NDIRECT + 1]) == 0) { ip-&gt;addrs[NDIRECT + 1] = addr = balloc(ip-&gt;dev); } bp = bread(ip-&gt;dev, addr); a = (uint*)bp-&gt;data; if((addr = a[bn / NINDIRECT]) == 0) { a[bn / NINDIRECT] = addr = balloc(ip-&gt;dev); log_write(bp); } brelse(bp); bp = bread(ip-&gt;dev, addr); a = (uint*)bp-&gt;data; bn %= NINDIRECT; if((addr = a[bn]) == 0) { a[bn] = addr = balloc(ip-&gt;dev); log_write(bp); } brelse(bp); return addr; } panic(\"bmap: out of range\")}voiditrunc(struct inode *ip){ int i, j, k; struct buf *bp, *bp2; uint *a, *a2; //... if(ip-&gt;addrs[NDIRECT + 1]) { bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + 1]); a = (uint*)bp-&gt;data; for(j = 0; j &lt; NINDIRECT; ++j) { if(a[j]) { bp2 = bread(ip-&gt;dev, a[j]); a2 = (uint*)bp2-&gt;data; for(k = 0; k &lt; NINDIRECT; ++k) { if(a2[k]) { bfree(ip-&gt;dev, a2[k]); } } brelse(bp2); bfree(ip-&gt;dev, a[j]); a[j] = 0; } } brelse(bp); bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + 1]); ip-&gt;addrs[NDIRECT + 1] = 0; } ip-&gt;size = 0; iupdate(ip);} 1.1.3 运行结果 1.2 Symbolic links1You will implement the symlink(char *target, char *path) system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. Your solution is complete when the tests produce the following output (including usertests succeeding). 1.2.1 解题过程 分别于kernel/syscall.h, kernel/syscall.c, user/usys.pl 和 user/user.h添加有关symlink系统调用的定义声明。 添加T_SYMLINK到kernel/stat.h中 添加O_NOFOLLOW到kernel/fcntl.h中 在kernel/sysfile.c中实现功能为生成符号链接的sys_symlink() 在kernel/fs.h定义NSYMLINK用于表示最大的符号连接深度 在kernel/sysfile.c中新增函数follow_symlink() 修改kernel/sysfile.c 的 sys_open() 1.2.2 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// Makefile$U/_symlinktest\\// kernel/syscall.h#define SYS_symlink 22// kernel/syscall.cextern uint64 sys_symlink(void);[SYS_symlink] sys_symlink,// ...uint64 sys_symlink(void) { char target[MAXPATH], path[MAXPATH]; struct inode *ip; int n; if ((n = argstr(0, target, MAXPATH)) &lt; 0 || argstr(1, path, MAXPATH) &lt; 0) { return -1; } begin_op(); // create the symlink's inode if((ip = create(path, T_SYMLINK, 0, 0)) == 0) { end_op(); return -1; } // write the target path to the inode if(writei(ip, 0, (uint64)target, 0, n) != n) { iunlockput(ip); end_op(); return -1; } iunlockput(ip); end_op(); return 0;}static struct inode* follow_symlink(struct inode* ip) { uint inums[NSYMLINK]; int i, j; char target[MAXPATH]; for(i = 0; i &lt; NSYMLINK; ++i) { inums[i] = ip-&gt;inum; if(readi(ip, 0, (uint64)target, 0, MAXPATH) &lt;= 0) { iunlockput(ip); printf(\"open_symlink: open symlink failed\\n\"); return 0; } iunlockput(ip); if((ip = namei(target)) == 0) { printf(\"open_symlink: path \\\"%s\\\" is not exist\\n\", target); return 0; } for(j = 0; j &lt;= i; ++j) { if(ip-&gt;inum == inums[j]) { printf(\"open_symlink: links form a cycle\\n\"); return 0; } } ilock(ip); if(ip-&gt;type != T_SYMLINK) { return ip; } } iunlockput(ip); printf(\"open_symlink: the depth of links reaches the limit\\n\"); return 0;}uint64sys_open(void){ // ... if(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; 0 || ip-&gt;major &gt;= NDEV)){ iunlockput(ip); end_op(); return -1; } // handle the symlink - lab9-2 if(ip-&gt;type == T_SYMLINK &amp;&amp; (omode &amp; O_NOFOLLOW) == 0) { if((ip = follow_symlink(ip)) == 0) { end_op(); return -1; } } if((f = filealloc()) == 0 || (fd = fdalloc(f)) &lt; 0){ if(f) fileclose(f); iunlockput(ip); end_op(); return -1; } // ...}// user/usys.plentry(\"symlink\");// user/user.hint symlink(char *target, char *path);// kernel/stat.h#define T_SYMLINK 4// kernel/fcntl.h#define O_NOFOLLOW 0x004// kernel/fs.h#define NSYMLINK 10 1.2.3 运行结果 2.实验心得​ 非常好奇Large files的$bigfile 和 $usertests 的 writebig到底是多”big”呢，等了快20分钟他的bigbig file，真的很big。 ​ 第二个sys_open函数的修改有点复杂，是否递归或者还是直接打开symlink。文件链接是一个iNode储存的的其实是另一个inode的路径，通过前一个inode找下一个inode，然后再查看另一个inode的值，如果仍是一个inode的路径的话，就继续递归找下去。","categories":[],"tags":[]},{"title":"OS LAB3 实验报告","slug":"OS项目设计-lab3实验报告","date":"2022-10-20T16:00:00.000Z","updated":"2023-04-08T04:31:25.030Z","comments":true,"path":"posts/os-lab3.html","link":"","permalink":"http://dayswithvenki.top/posts/os-lab3.html","excerpt":"","text":"Lab3 页表和进程的内存管理0. 实验前：切换至Lab3分支在xv6-labs-2021文件夹下运行终端，并且运行以下命令： 123$ git fetch$ git checkout syscall$ make clean 发现git check out命令发生错误，提示本地保存需要提交或存储后才能切换分支。 运行命令 git stash 切换成功。 1. 页表和进程的内存管理1.1 Speed up system calls1Some operating systems (e.g., Linux) speed up certain system calls by sharing data in a read-only region between userspace and the kernel. This eliminates the need for kernel crossings when performing these system calls. To help you learn how to insert mappings into a page table, your first task is to implement this optimization for the getpid() system call in xv6. 1.1.1 解题过程 在kernel/proc.h中的struct proc在增加一个域，存储共享内存块的物理地址。 在kernel/proc.c的allocproc函数中增加申请共享内存页。 在kernel/proc.c的proc_pagetable函数中增加在内核中共享内存页的初始化，以及对共享内存块的页表初始化。 在kernel/proc.c的freeproc函数中增加释放共享内存块。 在kernel/proc.c的proc_freepagetable函数中增加一行释放页表中共享内存页项。 1.1.2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243// kernel/proc.hstruct proc *parent;...struct inode *cwd;struct usyscall *usyscall;// kernel/proc.callocproc(void){ struct proc *p; ... if((p-&gt;usyscall = (struct usyscall *)kalloc()) == 0){ freeproc(p); release(&amp;p-&gt;lock); return 0; } ...}extern pagetable_t kernel_pagetable; ...pagetable_tproc_pagetable(struct proc *p) static voidfreeproc(struct proc *p){ ... if(p-&gt;usyscall) kfree((void*)p-&gt;usyscall); p-&gt;usyscall = 0; ...}voidproc_freepagetable(pagetable_t pagetable, uint64 sz){ ... uvmunmap(pagetable, USYSCALL, 1, 0);} 1.2 Print a page table1To help you visualize RISC-V page tables, and perhaps to aid future debugging, your second task is to write a function that prints the contents of a page table. 1.2.1 解题过程 模仿freewalk()编写vmprint()函数，并添加在kernel/vm.c中。 在kernel/defs.h中定义vmprint的原型，以便可以从exec.c调用它。 在kernel/exec.c中的返回argc之前插入if (p-&gt;pid==1) vmprint(p-&gt;pagetable)，以输出第一个进程的页表。 1.2.2 代码12345678910111213141516171819202122232425262728293031323334353637383940// kernel/vm.cvoid printwalk(pagetable_t pagetable, uint level) { char* prefix; if (level == 2) prefix = \"..\"; else if (level == 1) prefix = \".. ..\"; else prefix = \".. .. ..\"; for(int i = 0; i &lt; 512; i++){ pte_t pte = pagetable[i]; if(pte &amp; PTE_V){ uint64 pa = PTE2PA(pte); printf(\"%s%d: pte %p pa %p\\n\", prefix, i, pte, pa); if((pte &amp; (PTE_R|PTE_W|PTE_X)) == 0){ printwalk((pagetable_t)pa, level - 1); } } }} voidvmprint(pagetable_t pagetable) { printf(\"page table %p\\n\", pagetable); printwalk(pagetable, 2);}//kernel/defs.h// vm.c...void vmprint(pagetable_t);//kernel/exec.c... if (p-&gt;pid == 1) vmprint(p-&gt;pagetable); return argc; // this ends up in a0, the first argument to main(argc, argv) 1.2.3 运行结果测试 1.3 Detecting which pages have been accessed1Some garbage collectors (a form of automatic memory management) can benefit from information about which pages have been accessed (read or write). In this part of the lab, you will add a new feature to xv6 that detects and reports this information to userspace by inspecting the access bits in the RISC-V page table. The RISC-V hardware page walker marks these bits in the PTE whenever it resolves a TLB miss. 1.3.1 解题过程 在kernel/riscv.h中定义常量PTE_A。 在kernel/sysproc.c中编写sys_pgaccess函数。 1.3.2 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// kernel/riscv.h...#define PTE_A (1L &lt;&lt; 6) // kernel/sysproc.c#ifdef LAB_PGTBLintsys_pgaccess(void){ uint64 base; uint64 mask; int len; pagetable_t pagetable = 0; unsigned int procmask = 0 ; pte_t *pte; struct proc *p = myproc(); if(argaddr(0, &amp;base) &lt; 0 || argint(1, &amp;len) &lt; 0 || argaddr(2, &amp;mask) &lt; 0) return -1; if (len &gt; sizeof(int)*8) len = sizeof(int)*8; for(int i=0; i&lt;len; i++) { pagetable = p-&gt;pagetable; if(base &gt;= MAXVA) panic(\"pgaccess\"); for(int level = 2; level &gt; 0; level--) { pte = &amp;pagetable[PX(level, base)]; if(*pte &amp; PTE_V) { pagetable = (pagetable_t)PTE2PA(*pte); } else { return -1; } } pte = &amp;pagetable[PX(0, base)]; if(pte == 0) return -1; if((*pte &amp; PTE_V) == 0) return -1; if((*pte &amp; PTE_U) == 0) return -1; if(*pte &amp; PTE_A) { procmask = procmask | (1L &lt;&lt; i); *pte = *pte &amp; (~PTE_A); } base += PGSIZE; } pagetable = p-&gt;pagetable; return copyout(pagetable, mask, (char *) &amp;procmask, sizeof(unsigned int));}#endif 2.实验心得​ 一些操作系统(如Linux)通过在用户空间和内核之间的只读区域共享数据来加速某些系统调用。其中为了实现这一过程需要先添加一个存储共享内存块的物理地址-&gt;增加申请共享内存页-&gt;增加在内核中共享内存页的初始化，以及对共享内存块的页表初始化-&gt;增加释放共享内存块-&gt;释放页表中共享内存页项。 ​ 而当需要模拟系统遍历页表的时候，可以先通过观察系统本身是如何遍历的，然后按着freewalk()函数编写输出遍历打印页表的函数vmprint()。","categories":[],"tags":[]},{"title":"OS LAB2 实验报告","slug":"OS项目设计-lab2实验报告","date":"2022-09-30T16:00:00.000Z","updated":"2023-04-08T04:31:07.198Z","comments":true,"path":"posts/os-lab2.html","link":"","permalink":"http://dayswithvenki.top/posts/os-lab2.html","excerpt":"","text":"Lab2系统调用0. 实验前：切换至Lab2分支在xv6-labs-2021文件夹下运行终端，并且运行以下命令： 123$ git fetch$ git checkout syscall$ make clean 切换成功。 1. 新的系统调用1.1 System call tracing1In this assignment you will add a system call tracing feature that may help you when debugging later labs. You'll create a new trace system call that will control tracing. It should take one argument, an integer \"mask\", whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call's number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don't need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes. 1.1.1 解题过程 在Makefile UPROGS下新增$U/_trace\\ 执行make qemu，结果如下： 为user/user.h ； user/usys.pl ； kernel/syscall.h 添加trace的原型或声明 make qemu 成功，但是执行trace指令失败： kernel/sysproc.c 、 kernel/proc.h 、 kernel/syscall.c 加入对应的实现代码 修改kernel/proc.c fork()，以便子孙进程也能够被追踪 修改 kernel/syscall.c 的 syscall()，以输出相应的跟踪信息 此时结果： 发现进程名有误，再次修改syscall()，添加一个字符数组，用以对相关系统调用名的打印输出: 1.1.2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// MakefileUPROGS=\\ ... $U/_trace// user/user.h int trace(int);// kernel/syscall.h#define SYS_trace 22// user/usys.plentry(\"trace\");// kernel/syscall.c extern uint64 sys_trace(void);static uint64 (*syscalls[])(void) = {[SYS_fork] sys_fork,...[SYS_trace] sys_trace,};// kernel/sysproc.cuint64sys_trace(void){ int pid; if(argint(0, &amp;pid) &lt; 0) return -1; myproc()-&gt;tracemask = pid; return 0;}// kernel/proc.hstruct proc { struct spinlock lock;... int tracemask;};// kernel/proc.cintfork(void){ int i, pid; struct proc *np; struct proc *p = myproc(); if((np = allocproc()) == 0){ return -1; } np-&gt;tracemask = p-&gt;tracemask; ...}// kernel/syscall.c...static char syscall_name[23][16] = {\"fork\", \"exit\", \"wait\", \"pipe\", \"read\", \"kill\", \"exec\", \"fstat\", \"chdir\", \"dup\", \"getpid\", \"sbrk\", \"sleep\", \"uptime\", \"open\", \"write\", \"mknod\", \"unlink\", \"link\", \"mkdir\", \"close\", \"trace\", \"sysinfo\"};voidsyscall(void){ int num; struct proc *p = myproc(); num = p-&gt;trapframe-&gt;a7; if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) { p-&gt;trapframe-&gt;a0 = syscalls[num](); if(p-&gt;tracemask &gt; 0 &amp;&amp; (p-&gt;tracemask&amp;(1&lt;&lt;num))) { printf(\"%d: syscall %s -&gt; %d\\n\", p-&gt;pid, syscall_name[num-1], p-&gt;trapframe-&gt;a0); } } else { printf(\"%d %s: unknown sys call %d\\n\", p-&gt;pid, p-&gt;name, num); p-&gt;trapframe-&gt;a0 = -1; }} 1.1.3 运行结果测试 1.2 Sysinfo1In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints \"sysinfotest: OK\". 1.2.1 解题过程 在Makefile UPROGS下新增$U/_sysinfotest\\ 为user/user.h ； user/usys.pl ； kernel/syscall.h 添加trace的原型或声明 声明并定义state为UNUSED的进程数、当前进程空闲的文件描述符数量的函数 定义sysinfo 1.2.2 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// MakefileUPROGS=\\ ... $U/_sysinfotest// user/user.h struct sysinfo;... int sysinfo(struct sysinfo *);// kernel/syscall.h#define SYS_sysinfo 23// user/usys.plentry(\"sysinfo\");// kernel/syscall.c extern uint64 sys_sysinfo(void);static uint64 (*syscalls[])(void) = {[SYS_fork] sys_fork,...[SYS_sysinfo] sys_sysinfo,};// kernel/sysproc.c#include \"sysinfo.h\"uint64sys_sysinfo(void){ uint64 addr; if (argaddr(0, &amp;addr) &lt; 0) return -1; struct proc *p = myproc(); struct sysinfo si; si.freemem = getfreemem(); si.nproc = getnproc(); if (copyout(p-&gt;pagetable, addr, (char *)&amp;si, sizeof(si)) &lt; 0) return -1; return 0;}// kernel/proc.cuint64getnproc(void){ uint64 n = 0; struct proc *p; for (p = proc; p &lt; &amp;proc[NPROC]; ++p) { if (p-&gt;state != UNUSED) ++n; } return n;} 1.2.3 运行结果测试 2.实验心得​ 首先，需要了解清楚xv6的源码的某个函数的具体功能，以及源码与源码之间的关系，才能够好好地新增新的系统调用；并且，当完成一个实验的输出后，需要及时与官方文档中的结果进行比对，查看输出结果的区别在于哪个变量的值，如本次实验1中我第一次的结果缺少了系统调用名字的数组以及引用，导致所有系统调用名都是父程序的调用名，而缺少了子孙程序的调用名；最后，一定要记得引入需要用到的头文件，否则将需要很多的时间对函数进行检查，却找不到报错的原因。","categories":[],"tags":[]},{"title":"Django数据库操作","slug":"Django2","date":"2022-09-21T07:49:56.471Z","updated":"2022-09-21T14:56:16.548Z","comments":true,"path":"posts/db-of-django.html","link":"","permalink":"http://dayswithvenki.top/posts/db-of-django.html","excerpt":"","text":"Django项目 0.说在前面0.1 Django ORMDjango 模型使用自带的 ORM。 对象关系映射（Object Relational Mapping，简称 ORM ）用于实现面向对象编程语言里不同类型系统的数据之间的转换。 ORM 在业务逻辑层和数据库层之间充当了桥梁的作用。 ORM 是通过使用描述对象和数据库之间的映射的元数据，将程序中的对象自动持久化到数据库中。 使用 ORM 的好处： 提高开发效率。 不同数据库可以平滑切换。 使用 ORM 的缺点： ORM 代码转换为 SQL 语句时，需要花费一定的时间，执行效率会有所降低。 长期写 ORM 代码，会降低编写 SQL 语句的能力。 ORM 解析过程: 1、ORM 会将 Python 代码转成为 SQL 语句。 2、SQL 语句通过 pymysql 传送到数据库服务端。 3、在数据库中执行 SQL 语句并将结果返回。 ORM 对应关系表： 1.连接数据库1.1 直接下载MySQL（5.7版本以上） 将端口Port设置为3306，管理员Management User为root，密码Password为123456。 运行以下命令启动MySQL服务。 1net start mysql 1.2 通过Docker安装MySQLWindows Terminal运行以下命令： 1docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest 在Docker container 启动 MySQL服务。 1.3 Django项目连接MySQL数据库1.3.1 安装MySQLClient1pip install mysqlclient 1.3.2 配置settings文件打开settings.py项目配置文件 找到DATABASES配置项，并按以下修改： 1234567891011121314# settings.pyDATABASES = { 'default': { # 连接本地mysql数据库 'ENGINE': 'django.db.backends.mysql', 'NAME': 'mysql', # 你的数据库名 'USER': 'root', # 你的用户名 'PASSWORD': '123456', # 你的密码 'HOST': 'localhost', # 本地连接 'PORT': '3306', # 本地端口号 }} 2. 建表并进行简单的增删改操作2.1 建立表格打开APP下的models.py文件 假设要创建一个评价模块，其中： 需要编码，模块名称，分值 123456models.pyclass Evaluation(models.Model): id = models.AutoField(primary_key=True, verbose_name=\"编码\") name = models.CharField(verbose_name=\"模块名称\", max_length=32) score = models.PositiveIntegerField(verbose_name=\"分值\", max_length=2) # 正整数 在终端运行以下命令: 12python manage.py makemigrationspython manage.py migrate 可以看到数据库内以及建好一个名为app01_evalution的表，表的结构如下图所示： 2.2 数据增删改先于urls.py 文件的urlpatterns添加以下代码： 123456789# urls.pyurlpatterns = [ ..., path('test/add/', views.test_add), path('test/edit/', views.test_edit), path('test/delete/', views.test_delete), path('test/list/', views.test_list),] 2.2.1 新增数据 新增如下数据 ID 模板名称 分值 1 模块1：选择题目 20 2 模块2：掌握情况 10 3 Need_TO_DELETE 0 于views.py 添加: 12345678910from django.shortcuts import render,redirect,HttpResponsefrom app01 import modelsdef test_add(request): \"\"\"添加评价\"\"\" names = ['模块1：选择题目', '模块2：掌握情况', 'Need_TO_DELETE'] scores = [20, 10, 0] for i in range(3): models.Evaluation.objects.create(name=names[i], score=scores[i]) return HttpResponse('添加成功') 浏览器访问 http://localhost:8888/test/add/ 可观察到已经有新增的数据： 2.2.2 修改数据 将id为3的数据的score 改为 5 123456# views.pydef test_edit(request): \"\"\"修改评价\"\"\" models.Evaluation.objects.filter(id=3).update(score=5) return HttpResponse('修改成功') 浏览器访问http://localhost:8888/test/edit/ 2.2.3 删除数据 删除id为3的数据 123456# views.pydef test_delete(request): \"\"\"删除评价\"\"\" models.Evaluation.objects.filter(id=3).delete() return HttpResponse('删除成功') 浏览器访问http://localhost:8888/test/delete/ 2.2.4 展示所有数据 在Python中输出表中的数据并展示在页面上 12345def test_list(request): datas = models.Evaluation.objects.all() for data in datas: print(data.id, data.name, data.score) return render(request, 'test.html', {'datas': datas}) 在test.html的nav标签下新增以下代码： 12345678910111213141516171819202122232425262728293031&lt;div class=\"card\"&gt; &lt;div class=\"card-header\"&gt; 评价模块 &lt;/div&gt; &lt;div class=\"card-body\"&gt; &lt;table class=\"table table-bordered table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=\"col\"&gt;编码&lt;/th&gt; &lt;th scope=\"col\"&gt;模块名称&lt;/th&gt; &lt;th scope=\"col\"&gt;分值&lt;/th&gt; &lt;th scope=\"col\"&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; {% for obj in datas %} &lt;tr&gt; &lt;th scope=\"row\"&gt;{{ obj.id }}&lt;/th&gt; &lt;td&gt;{{ obj.name }}&lt;/td&gt; &lt;td&gt;{{ obj.score }}&lt;/td&gt; &lt;td&gt; &lt;a href=\"#\" class=\"btn btn-primary btn-sm\"&gt;编辑&lt;/a&gt; &lt;a href=\"#\" class=\"btn btn-danger btn-sm\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; {% endfor %} &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; python控制台输出结果为： 浏览器返回如下：","categories":[],"tags":[{"name":"👨‍💻Django","slug":"👨‍💻Django","permalink":"http://dayswithvenki.top/tags/%F0%9F%91%A8%E2%80%8D%F0%9F%92%BBDjango/"}]},{"title":"Django的配置与安装","slug":"Django1","date":"2022-09-21T01:14:45.967Z","updated":"2022-09-21T14:59:28.707Z","comments":true,"path":"posts/install-django.html","link":"","permalink":"http://dayswithvenki.top/posts/install-django.html","excerpt":"","text":"Django项目 1.安装Django123456pip install django# Python终端验证安装&gt;&gt;&gt; import django&gt;&gt;&gt; django.get_version()'4.1.1' 1.1终端创建Django项目1django-admin startproject DjangoProject 目录结构： 12345678910$ cd DjangoProject/$ tree.|-- DjangoProject| |-- __init__.py| |-- asgi.py| |-- settings.py| |-- urls.py| `-- wsgi.py`-- manage.py 目录说明： DjangoProject: 项目容器 manage.py: 命令行工具 DjangoProject/ init .py: 告诉Python该目录为Python包 DjangoProject/asgi.py: ASGI兼容的Web服务器入口，以便项目运行 DjangoProject/settings.py: 当前项目的配置文件 DjangoProject/urls.py: 当前项目的URL声明，由Django驱动的网站”目录“ DjangoProject/wsgi.py: WSGI兼容的Web服务器入口，以便项目运行 1.2PyCharm创建Django项目 配置启动项： 运行即可自动启动项目。 2. 创建可以在浏览器查看的页面2.1 创建并注册APP2.1.1创建APPPycharm左上角目录&gt;工具&gt;运行 manage.py 任务： ​ 在启动的窗口中 1manage.py@djangoProject2 &gt; startapp app01 新建app目录如下： 2.1.2 注册APP找到DjangoProject/settings.py &gt; INSTALLED_APPS 加入以下内容 2.2 启动项目终端启动（Pycharm直接运行项目即可）： 1python manage.py runserver 8888 出现链接http://127.0.0.1:8888/点击跳转后： Django项目启动成功。 3.创建可访问页面3.1在APP文件夹下创建templates和static文件夹templates：用于存放html文件。 static：用于存放静态文件。 3.1.1 于templates下新建html文件（如：test.html） 3.1.2 于static下新建css目录与js目录(1)在CSS目录下新建bootstrap的bootstrap.min.css文件 将https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.1/css/bootstrap.min.css 复制进入新建的bootstrap.min.css中 (2)在JS目录下新建boostrap.bundle.min.js 将https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.2.1/js/bootstrap.bundle.min.js 复制进新建的bootstrap.bundle.min.js中 3.1.3 于html文件中引入js和css文件并增添内容(1) 将html改为以下： 1234567891011121314151617181920212223+ {% load static %}&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;+ &lt;link href=\"{% static 'css/bootstrap.min.css' %}\" rel=\"stylesheet\" /&gt;&lt;/head&gt;&lt;body&gt;+ &lt;div class=\"container\"&gt;+ &lt;nav class=\"navbar navbar-light bg-light\"&gt;+ &lt;div class=\"container-fluid\"&gt;+ &lt;a class=\"navbar-brand\" href=\"#\"&gt;+ &lt;img src=\"https://v5.bootcss.com/docs/5.1/assets/brand/bootstrap-logo.svg\" alt=\"\" width=\"30\" height=\"24\"+ class=\"d-inline-block align-text-top\"&gt;+ Bootstrap+ &lt;/a&gt;+ &lt;/div&gt;+ &lt;/nav&gt;+ &lt;/div&gt;&lt;/body&gt;+&lt;script src=\"{% static 'js/boostrap.bundle.min.js' %}\"&gt;&lt;/script&gt;&lt;/html&gt; 3.2 使新增的html可访问3.2.1 新建视图函数打开APP中的views.py文件 增加以下代码： 12def newtest(request): return render(request, 'test.html') 3.2.2 配置URL绑定视图函数打开项目中的urls.py文件 (1)从app中import views 1from app01 import views # app01是新建的app名 (2)在urlpatterns列表下新增path 1path('test/', views.newtest), # test/为你需要访问的url 3.2.2.1 path函数：Django path() 可以接收四个参数，分别是两个必选参数：route、view 和两个可选参数：kwargs、name。 语法格式： 1path(route, view, kwargs=None, name=None) route: 字符串，表示 URL 规则，与之匹配的 URL 会执行对应的第二个参数 view。 view: 用于执行与正则表达式匹配的 URL 请求。 kwargs: 视图使用的字典类型的参数。 name: 用来反向获取 URL。 3.2.3 访问新建的页面3.2.3.1 浏览器访问 127.0.0.1:8888页面变为： 可以看到已经可以访问以下URL： 1.admin/ 2.test/ 3.2.3.2 访问127.0.0.1:8888/test/ 到这里，以及完成项目的建立和运行，以及URL和视图函数的配置与绑定。","categories":[],"tags":[{"name":"👨‍💻Django","slug":"👨‍💻Django","permalink":"http://dayswithvenki.top/tags/%F0%9F%91%A8%E2%80%8D%F0%9F%92%BBDjango/"}]},{"title":"OS LAB1 实验报告","slug":"OS-lab1","date":"2022-09-18T14:30:56.651Z","updated":"2022-09-18T14:47:54.035Z","comments":true,"path":"posts/os-lab1.html","link":"","permalink":"http://dayswithvenki.top/posts/os-lab1.html","excerpt":"","text":"xv6环境搭建过程1. 安装VMware虚拟机2. 下载Ubuntu ISO包3. 于VMware创建Ubuntu 系统虚拟机4. xv6的环境搭建4.1 在虚拟机中运行以下命令1sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu ​ 运行中出现以下错误 ​ 按提示运行命令: 1sudo apt-get update ​ 再次运行命令1后安装成功。 ​ 检验qwmu是否安装成功: 4.2 安装Xv6​ 安装git: 1sudo apt install git ​ 然后运行以下命令： 1234git clone git://g.csail.mit.edu/xv6-labs-2021cd xv6-labs-2021git checkout utilgit commit -am 'my solution for util lab exercise 1' ​ 此时需要配置用户名、邮箱： 12git config --global user.name 'Kevin'git config --global user.email '1171407839@qq.com' ​ 在xv6目录下运行以下命令: 1make qemu ​ 得到以下结果： XV6环境搭建完毕。 5.三个练手小程序5.1 sleep1Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c. 5.1.1 解题思路​ 从user/user.h 中system call可以看到sleep函数的声明为 int sleep(int); ​ 所以，可以从main中的参数argc(argument count)确定参数的个数，其中，第一个参数为程序的名称，即sleep，而正确运行还需要一个且仅需要一个int型参数。所以当argc不为2时，则输出错误信息并退出；否则，将argv[1]转化为int传入sleep()，随后正常退出。 5.1.2 代码123456789101112131415#include \"kernel/types.h\"#include \"user/user.h\"#include \"kernel/stat.h\"int main(int argc,const char* argv[]){ // argv[0]为程序的名称sleep,argv[1]为参数 if(argc != 2){ // 若除了sleep外参数传入个数不为1 printf(\"%s\",\"Error！Wrong Format!\"); exit(1); // 错误退出 } sleep(atoi(argv[1])); // 将argv[1]转化为整型传入sleep exit(0);} 5.1.3 运行结果测试 5.2 pingpong1Write a program that uses UNIX system calls to ''ping-pong'' a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print \"&lt;pid&gt;: received ping\", where &lt;pid&gt; is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print \"&lt;pid&gt;: received pong\", and exit. Your solution should be in the file user/pingpong.c. 5.2.1 解题思路​ fork()用于创建子进程，当fork返回0时，表示当前正处于子进程；在父进程中，fork返回新创建子进程的进程ID；若出现错误，fork返回负值。 ​ pipe()被调用时开辟一块缓冲区（管道）用于通信，拥有读端与写端，可通过filedes参数传出给用户程序两个文件描述符，其中filedes[0]指向读端，filedes[1]指向写端。管道在程序中如同打开的文件，所以可以通过write(filedes[1])和read(filedes[0])读写内核缓冲区。 ​ 当前进程为子进程时，关闭子进程的写与父进程的读端，当子进程从管道0读到父进程写入管道1的字节时，输出当前pid 与 ping；当前进程为父进程时，关闭父进程的写与子进程的读端，当父进程从管道1读到子进程写入管道0的字节时，输出当前pid 与 pong，最后关闭两个管道的所有读写端口。 5.2.2 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"const int READ = 0;const int WRITE = 1;int main(){ int child; //若此处写成int child = fork() 测试时会报错 int filede0[2]; // 子进程的读写端 int filede1[2]; // 父进程的读写端 if (pipe(filede0) || pipe(filede1)) // pipe调用返回-1表示失败，返回1表示成功 { printf(\"Error!Pipe Call Fails!\"); exit(1); } if ((child= fork()) == 0) // 创建子进程且当前为子进程时 { close(filede0[WRITE]); // 关闭子进程的写 close(filede1[READ]); // 关闭父进程的读 write(filede0[WRITE], \"child\", 1); read(filede1[READ], \"from father\", 1); printf(\"%d: received ping\\n\", getpid()); //先关闭读再关闭写 close(filede0[READ]); close(filede1[WRITE]); exit(0); } else { close(filede0[READ]); close(filede1[WRITE]); write(filede0[WRITE], \"father\", 1); read(filede1[READ], \"from child\", 1); printf(\"%d: received pong\\n\", getpid()); close(filede1[READ]); close(filede0[WRITE]); wait(0); } exit(0);} 5.2.3 运行结果测试 5.3 primes1Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c. 5.3.1 解题思路​ 进程1输入2-35；进程2打印第一个质数2后，将所有进程1输入的、是进程2打印的质数的倍数的丢弃，把剩余的交给进程3；进程3打印第二个质数3，将所有进程2输入的、是进程3打印的质数的倍数丢弃，把剩余交给进程4……一直重复，直至剩余的输入为空。 5.3.2 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include \"kernel/types.h\"#include \"kernel/stat.h\"#include \"user/user.h\"const int MAX = 35;const int READ = 0;const int WRITE = 1;void primes(int pre_read){ int prime; if (read(pre_read, &amp;prime, sizeof(int)) &lt;= 0) // 若prime不为空或文件尾 exit(0); printf(\"prime %d\\n\", prime); int filede[2]; pipe(filede); if (fork() == 0) // 若为上个进程的子进程，即清空上一个输出的质数的倍数后 { close(filede[WRITE]); // 关闭写 primes(filede[READ]); // 递归 close(filede[READ]); } else { int temp; close(filede[READ]); while (read(pre_read, &amp;temp, sizeof(int))) if (temp % prime != 0) // 剔除prime的倍数，将剩余的写回pipe中 write(filede[WRITE], &amp;temp, sizeof(int)); close(filede[WRITE]); wait(0); } exit(0);}int main(){ int filede[2]; pipe(filede); if (fork() == 0) { close(filede[WRITE]); primes(filede[READ]); close(filede[READ]); } else { close(filede[READ]); for(int i=2;i&lt;=MAX;i++) write(filede[WRITE],&amp;i,sizeof(int)); //将2-35依次写入filede close(filede[WRITE]); wait(0); } exit(0);} 5.3.3 运行结果测试 6.实验心得​ 首先，配置环境应该选比较充裕的时间，防止校园网网速过慢导致一个学生失去他的梦想，几个G的Ubuntu系统，以及几百M的VMware虚拟机软件等，还没开始配置一个下午就过去了；不仅如此，git clone 在 github+校园网双重debuff下，更是交出了10k/s的下载速度，看他下载又看了一晚上，不过最后也终于可以运行了。 ​ 回到练手小程序上，首先比较重要的是看懂hints的内容，对其中出现的如fork()，pipe()等系统调用，想要编写程序必须得先明白他们的作用，以及需要用到哪些参数，我自己是习惯先看中文的解释，等到差不多看明白能够使用了，再好好看看xv6内部是如何进行调用的。 ​ 最后，学好英语很重要，无论是Ubuntu系统的Terminal终端，还是各种官方的文档，都是全英的，报错信息都有自带的命令建议。","categories":[],"tags":[]},{"title":"对未来的小小规划","slug":"certificates","date":"2022-09-10T07:51:13.348Z","updated":"2022-09-18T14:39:36.548Z","comments":true,"path":"posts/expectation.html","link":"","permalink":"http://dayswithvenki.top/posts/expectation.html","excerpt":"","text":"关于网站维护​ &nbsp;&nbsp;宝宝呀宝宝，原来自从7月底之后，我就没有再怎么处理过我们网站啦。从8月1号入职开始我才慢慢体会到当工作啥的一起来之后，要维护一个网站的难度真的太大啦！！！特别是当我把很多很多东西都放到了国外的服务商之后，一但被墙，我就要花巨多巨多的时间去维护，功能越多，维护的东西也就越多啦！哎呀呀！！！！ 不过还好啦！也终于把现在有的东西维护好啦！！！然后还学了一些新知识，估计未来慢慢更改，维护成本会越来越低的！！！ 小小规划&nbsp;&nbsp;入职之后，特别是接触到许多项目开发后，对从前一些零零散散的知识体系会有一个很不一样的看法，然后现在刚开始，就尽量把前端的各种框架比如：Vue.js,Node.js之类的呀都多多了解清楚，然后把之前一直没有系统训练的HTML语法呀、CSS语法呀、JAVASCRIPT之类的都先做一个系统的学习；然后后端也需要去尽量学习学习，目前正在慢慢学Django的后端框架哇，总之现在对未来的小小希望，也从单纯的前端工程师-&gt;全栈工程师啦！ 认证展示&nbsp;&nbsp;最后这里呢，就留给自己展示展示在FreeCodeCamp上面获得的学习证书吧嘎嘎嘎，虽然呢，这些认证意义不大，也非常简单，但是还是放在这儿！留给自己臭美臭美吧！！！！哈哈哈哈哈哈嘎嘎嘎嘎嘎嘎！！！ 1.Responsive Web Design 2.JavaScript 算法和数据结构","categories":[],"tags":[{"name":"💻前端","slug":"💻前端","permalink":"http://dayswithvenki.top/tags/%F0%9F%92%BB%E5%89%8D%E7%AB%AF/"}]},{"title":"Python 多线程","slug":"Python8","date":"2022-07-16T07:20:00.000Z","updated":"2022-07-17T13:01:21.059Z","comments":true,"path":"posts/python-thread.html","link":"","permalink":"http://dayswithvenki.top/posts/python-thread.html","excerpt":"","text":"12345678910111213from threading import Threaddef func(): for i in range(1000): print('func', i)if __name__ == '__main__': t = Thread(target=func) # 创建线程并给线程安排任务 t.start() # 多线程状态为可以开始工作状态，具体执行时间由CPU决定 for i in range(1000): print('main', i) 运行结果: 1234567891011121314151617181920212223funcmain 0 0funcmain 1func 2func 3func 4 1main func 5func 6func2 7......funcmain 998992funcmain 999993main 994main 995main 996main 997main 998main 999","categories":[],"tags":[{"name":"🐍Python","slug":"🐍Python","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%8DPython/"},{"name":"🕷️爬虫","slug":"🕷️爬虫","permalink":"http://dayswithvenki.top/tags/%F0%9F%95%B7%EF%B8%8F%E7%88%AC%E8%99%AB/"}]},{"title":"Python 爬虫实战！","slug":"Python7","date":"2022-07-13T12:30:00.000Z","updated":"2022-09-18T13:28:00.570Z","comments":true,"path":"posts/python-exercises.html","link":"","permalink":"http://dayswithvenki.top/posts/python-exercises.html","excerpt":"","text":"注:爬虫需要遵循各网站根目录下的robots.txt协议！！！本篇文章仅用于个人学习记录使用，获取到的资源在当天已全部删除，且仅爬取网站其中的部分信息，并未涉及到其他用户的私人信息等，且并未以此产生非法牟利。 实战1:爬取某视频首页视频实战2:爬取某音乐评论实战1:爬取某视频首页视频爬取内容: 爬取结果: 实现过程及思路: 从网页主页url中打开控制台，获取主页的html源码，利用xpath解析得到这一块的子页面href。 打开子页面的源代码，发现视频并不在其中，则通过network中的Fetch/XHR查找视频来源。 从中得到Request URL，进行requests.get发现获取失败，并得到以下内容。 分析得到结果，是防盗链反爬导致的，回头找network内headers属性，将User-Agent,Cookie加入headers字典，再次使用requests.get发现仍然如此 ，最后发现是Referer防盗链造成的，Referer的值为子页面的href，将其组成键值对加入headers字典，再次进行requests.get，得到srcUrl。 对srcUrl进入发现还有最后一层反爬，通过比对正确的视频url和srcUrl发现：srcUrl是通过真正的url与systemTime组合修改的，找到其修改规律，用replace方法将systemTime改为f’cont-{video_id}’，得到最后正确的视频链接。 通过最后的write(requests.get(true_url).content)得到所需视频。 实现代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849\"\"\"7.13 Kevin防盗链处理 某视频 视频爬虫 爬取首页第一个大div里面所有视频\"\"\"import requestsfrom lxml import htmletree = html.etreeurl = 'https://www.pearvideo.com/'res = requests.get(url)tree = etree.HTML(res.text)href_list = tree.xpath('//*[@id=\"vervideoTlist\"]/div//@href')print(href_list)for href in href_list: url = 'https://www.pearvideo.com/'+ href video_id = url.split('_')[1] params = { 'contId': video_id } videoStatus = requests.get('https://www.pearvideo.com/videoStatus.jsp', params) new_url = videoStatus.url headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36', 'Cookie': '__secdyid=e9d7070e31f729879bd4edec9f3db4567721f9f23769837d021657708580; acw_tc=2f624a1916577085808321223e1c9d5da783477514d7ff177f8220c470bbf8; JSESSIONID=2EF2FE6E5DE5C57BD7DAA3C0C372BE69; PEAR_UUID=dd85645b-e891-4615-a677-a8d2db1df2a2; _uab_collina=165770858183026495245603; Hm_lvt_9707bc8d5f6bba210e7218b8496f076a=1657708583; p_h5_u=B2141296-37D6-4117-87E8-E50BC33AFE84; Hm_lpvt_9707bc8d5f6bba210e7218b8496f076a=1657708644; SERVERID=ed8d5ad7d9b044d0dd5993c7c771ef48|1657708664|1657708580', 'Referer': url } resp = requests.get(new_url, headers=headers) resp_json = resp.json() fake_url = resp_json['videoInfo']['videos']['srcUrl'] # 这里用切片方法组合得到真实的url再组合，没用对脑子,非常复杂 # srcUrl = https://video.pearvideo.com/mp4/third/20220712/1657710591280-11905134-122533-hd.mp4 # part_list1 = fake_url.split('/')[-1].split('-')[1:] # part_list2 = fake_url.split('-')[0].split('/')[0:-1] # part_left = '' # part_right = '' # for item in part_list1: # part_right += item+'-' # for it in part_list2: # part_left += it+'/' # true_url = part_left + 'cont-'+video_id + '-' + part_right.strip('-') # 以下使用replace方法 systemTime = resp_json['systemTime'] true_url = fake_url.replace(systemTime, f\"cont-{video_id}\") #print(true_url) video_name = f'{video_id}.mp4' with open('video/'+video_name, 'wb') as fw: resp2 = requests.get(true_url) fw.write(resp2.content)实战2:爬取某音乐评论爬取内容: 爬取结果:实现过程及思路: 查看网页源代码，发现评论并没有在源代码内，转而找NetWork下对应评论的请求，查看headers。 发现From Data内数据被加密。 解决思路： 找到未加密的参数 参考原来的加密逻辑加密自己的参数 请求到网址，得到加密信息 步骤： 寻找加密过程： 进入Call Stack查看上一步的，直至找到数据未加密的时候： 观察后可得到加密函数如下： ∴加密的过程为 windows.asrsea(加密前数据,xxx,xxx) 进一步找asrsea函数组的定义: 所以具体实参对应：d=data参数, e=buV0x([“流泪”, “强”]), f=buV0x(Rg4k.md), g=buV0x([“爱心”, “女孩”, “惊恐”, “大笑”])【参数efg可以从Console运行得出以下结果】 分析函数运行过程：在代码里有 实现代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394\"\"\"7.14 Kevin网易云音乐 热评 爬虫\"\"\"import requestsfrom Crypto.Cipher import AESfrom base64 import b64encodeimport jsond = '010001'f = '00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7'g = '0CoJUm6Qyw8W8jud'i = \"kyM74e2babr6Ktf3\"data = { \"rid\": \"R_SO_4_28160882\", \"threadId\": \"R_SO_4_28160882\", \"pageNo\": \"1\", \"pageSize\": \"20\", \"cursor\": \"-1\", \"offset\": \"0\", \"orderType\": \"1\", \"csrf_token\": \"4a42317491b25188649cd33d5ccfe8c4\"} # data为解密前的数据def get_encSecKey(): return \"5015aaf2b9d0c1487908bf12cd0afdac506c4e7527cb6805ead6f4f6fa363aed69d876a0a9ecf18caaadc09ff9a61dcbf868657e15bbd0a24a44c41b499e19d5e9eede71d3f99232f965515aef8fc282f15b7ee7816fd9b5ac2d3784f385f03213ea8882edafe47bf88b3cd0f120f441f9246348fb2d75b6799f8548b021b04b\"def get_params(data): # 默认所得为字符串 first = enc_params(data, g) second = enc_params(first, i) return seconddef to_16(data): pad = 16 - len(data) % 16 data += chr(pad)*pad return datadef enc_params(data, key): iv = '0102030405060708' data = to_16(data) aes = AES.new(key=key.encode(\"utf-8\"), IV=iv.encode('utf-8'), mode=AES.MODE_CBC) # 创建加密器 bs = aes.encrypt(data.encode('utf-8')) # 加密,加密的内容长度必须是16的倍数, return str(b64encode(bs), \"utf-8\")url = 'https://music.163.com/weapi/comment/resource/comments/get?csrf_token=4a42317491b25188649cd33d5ccfe8c4'# 处理加密过程\"\"\" function a(a) { # 返回随机16位字符串 var d, e, b = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\", c = \"\"; for (d = 0; a &gt; d; d += 1) # 循环16次 e = Math.random() * b.length, # 随机数 e = Math.floor(e), # 取整 c += b.charAt(e); # 取字符串 return c } function b(a, b) { var c = CryptoJS.enc.Utf8.parse(b) # b是秘钥 , d = CryptoJS.enc.Utf8.parse(\"0102030405060708\") , e = CryptoJS.enc.Utf8.parse(a) # e是数据 , f = CryptoJS.AES.encrypt(e, c, { # c是加密的秘钥 iv: d, # 偏移量 mode: CryptoJS.mode.CBC # 加密模式 }); return f.toString() } function c(a, b, c) { var d, e; return setMaxDigits(131), d = new RSAKeyPair(b,\"\",c), e = encryptedString(d, a) } function d(d, e, f, g) { var h = {} , i = a(16); # i是16位随机字符串 return h.encText = b(d, g), # g是秘钥 h.encText = b(h.encText, i), # 返回params，i是秘钥 h.encSecKey = c(i, e, f), #得到encSecKey 8===D 此时i已经是一个定制，所以可def一个函数get_encSecKey h } 具体调用: var bKB1x = window.asrsea( d=JSON.stringify(i9b), e=buV0x([\"流泪\", \"强\"]), f=buV0x(Rg4k.md), g=buV0x([\"爱心\", \"女孩\", \"惊恐\", \"大笑\"])); d:数据，e\"\"\"resp = requests.post(url, data={ \"params\": get_params(json.dumps(data)), \"encSecKey\": get_encSecKey()})print(resp.json())","categories":[],"tags":[{"name":"🐍Python","slug":"🐍Python","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%8DPython/"},{"name":"🕷️爬虫","slug":"🕷️爬虫","permalink":"http://dayswithvenki.top/tags/%F0%9F%95%B7%EF%B8%8F%E7%88%AC%E8%99%AB/"}]},{"title":"Python Xpath模块","slug":"Python6","date":"2022-07-12T08:18:00.000Z","updated":"2022-07-12T14:24:21.378Z","comments":true,"path":"posts/python-xpath1.html","link":"","permalink":"http://dayswithvenki.top/posts/python-xpath1.html","excerpt":"","text":"Xpath模块 from lxml import html etree = html.etree 使用到的HTML文件:123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;titile&gt;title&lt;/titile&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"https://www.baidu.com\"&gt;百度&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.google.com\"&gt;谷歌&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.sougou.com\"&gt;搜狗&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=\"feiji\"&gt;飞机&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"dapao\"&gt;大炮&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"huoche\"&gt;火车&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class=\"job\"&gt;李嘉诚&lt;/div&gt; &lt;div class=\"common\"&gt;胡辣汤&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一个小样例：1234567891011121314151617from lxml import htmltree = html.etree.parse(\"b.html\")# result = tree.xpath('/html')# result = tree.xpath('/html/body/ul/li/a/text()') # xpath索引从1开始# result = tree.xpath('/html/body/ol/li[2]/a/text()') # 指取该标签的内容result = tree.xpath('/html/body/ol/li/a[@href=\"dapao\"]/text()') # @href表示属性href等于双引号内内容print(result)li_list = tree.xpath('/html/body/ol/li')for li in li_list: tex = li.xpath('./a/@href') # 指取属性href的值 print(tex)print(tree.xpath('/html/body/div[1]/text()')) 可以通过浏览器控制台的功能快速得到xpath 一个实例123456789101112131415161718192021222324252627282930\"\"\"7.12 Kevin猪八戒网 Xpath 爬虫\"\"\"from lxml import htmlimport requestsetree = html.etreeurl = 'https://beijing.zbj.com/search/shop/?type=new&amp;kw=saas'resp = requests.get(url)html = etree.HTML(resp.text)divs = html.xpath('//*[@id=\"__layout\"]/div/div[3]/div/div[3]/div[4]/div[1]/div')for div in divs: name = div.xpath('./div[1]/div/div/a/div/div/div/div[1]/div[1]/div[2]/div[1]/text()') if len(name) != 0: com_name = name[0] else: com_name = \"no info\" city = div.xpath('./div[1]/div/div/a/div/div/div/div[1]/div[1]/div[2]/div[2]/text()') price = div.xpath('./div/div/div/a[@target=\"_blank\"]/div/div/div/div[1]/div[2]/div/div/text()') com_good = div.xpath('.//div[1]/div/div/a/div/div/div/div[2]/div[2]/text()') if len(city) != 0: city_name = (city[2][5:-1]) else: city_name = \"no info\" print(com_name, city_name, com_good[0], price[0]) # 公司名、所处城市、擅长、平均成交价格","categories":[],"tags":[{"name":"🐍Python","slug":"🐍Python","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%8DPython/"},{"name":"🕷️爬虫","slug":"🕷️爬虫","permalink":"http://dayswithvenki.top/tags/%F0%9F%95%B7%EF%B8%8F%E7%88%AC%E8%99%AB/"}]},{"title":"Python BS模块","slug":"Python5","date":"2022-07-12T05:38:32.877Z","updated":"2022-07-12T10:13:14.032Z","comments":true,"path":"posts/python-beautifulsoup.html","link":"","permalink":"http://dayswithvenki.top/posts/python-beautifulsoup.html","excerpt":"","text":"bs模块 from bs4 import BeautifulSoup 解析器 lxml HTML 解析器下的选择器标签选择器•选择元素、获取名称、获取属性、获取内容、嵌套选择、子节点和子孙节点、父节点和祖先节点、兄弟节点 •soup.prettify()、soup.title.name、soup.head、soup.p.string、soup.p[‘name’] 标准选择器 •soup.find_all(‘ul’)、find_parents()、find_next_siblings()、find_previous_siblings() •soup.find(‘ul’)、find_parent()、find_next_sibling()、find_previous_sibling() CSS选择器 soup.select()、soup.select_one()直接传入选择器参数 [.代表class,#代表id] 1234567soup.select('.panel .panel-heading')soup.select('ul li')soup.select('#list-2 .element')ul = soup.select('ul')[0]uid = ul['id']trs = soup.select('table tbody tr')title = trs[0].select_one('td a').text 一个样例1234567891011url = ''resp = requests.get(url)#解析数据# 1.把页面源代码交给BeautifulSoup处理，生成bs对象page = BeautifulSoup(resp.text, \"lxml\") #指定html解析器# 2.从bs对象中查找数据# find(标签,属性=值)# find_all（标签,属性=值)# table = page.find(\"table\", class_=\"hq_table\") #class是Python关键字table = page.find(\"table\", attrs={\"class\": \"hq_table\"}) #避免class 一个实例1234567891011121314151617181920212223242526\"\"\"7.12 Kevin优美图库 唯美壁纸 BeautifulSoup解析实例\"\"\"import requestsfrom bs4 import BeautifulSoupurl = 'https://www.umei.cc/bizhitupian/weimeibizhi/'resp = requests.get(url)resp.encoding = 'utf-8'page = BeautifulSoup(resp.text, \"lxml\")a_list = page.find(\"ul\", class_=\"pic-list after\").find_all(\"a\")for a in a_list: curl = 'https://www.umei.cc'+a.get('href') resp2 = requests.get(curl) resp2.encoding = 'utf-8' page2 = BeautifulSoup(resp2.text, \"lxml\") src = page2.find(\"section\", class_=\"img-content\").find(\"img\").get('src') img_name = src.split('/')[-1] # 以网站图片名字命名图片 src = requests.get(src) with open(\"img/\"+img_name, 'wb') as fw: fw.write(src.content) # 以字节方式写入文件 print(img_name, \"over!\")","categories":[],"tags":[{"name":"🐍Python","slug":"🐍Python","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%8DPython/"},{"name":"🕷️爬虫","slug":"🕷️爬虫","permalink":"http://dayswithvenki.top/tags/%F0%9F%95%B7%EF%B8%8F%E7%88%AC%E8%99%AB/"}]},{"title":"Python Re模块","slug":"Python4","date":"2022-07-11T07:15:00.000Z","updated":"2022-07-11T12:41:29.262Z","comments":true,"path":"posts/python-remodule.html","link":"","permalink":"http://dayswithvenki.top/posts/python-remodule.html","excerpt":"","text":"re模块 import re findall：匹配字符串中所有符合正则的内容，返回迭代器。 lst = re.findall(r”\\d+”, “我的电话号码一个是：12345,另一个是：13579”)print(lst) [‘12345’,’13579’] finditer:匹配字符串中所有的内容，返回迭代器,获取内容需要.group()。it = re.finditer(r”\\d+”, “我的电话号码一个是：12345,另一个是：13579”)for i in it: print(i.group()) 1234513579 search:返回match对象，获取数据需要.group()，找到一个结果就返回。s = re.search(r”\\d+”, “我的电话号码一个是：12345,另一个是：13579”)print(s.group()) 12345 match:从头开始匹配与search类似s = re.search(r”\\d+”, “12345,另一个是：13579”)print(s.group()) 12345 预加载正则表达式obj = re.compile(r”\\d+”)rets = obj.finditer(“我的电话号码一个是：12345,另一个是：13579”)for ret in rets: print(ret.group()) 1234513579 一个样例[选择符合表达式内容的部分内容方法]: 123456789101112131415import res = \"\"\"&lt;div class='Jay'&gt;&lt;span id='1'&gt;周杰伦&lt;/span&gt;&lt;/div&gt;&lt;div class='Eason'&gt;&lt;span id='2'&gt;陈奕迅&lt;/span&gt;&lt;/div&gt;&lt;div class='JJ'&gt;&lt;span id='3'&gt;林俊杰&lt;/span&gt;&lt;/div&gt;\"\"\"# (?p&lt;分组名字&gt;正则) 可以单独从正则匹配的内容中进一步提取内容# re.S 令.能够匹配所有字符obj = re.compile(r\"&lt;div class='.*?'&gt;&lt;span id='(?P&lt;top_id&gt;\\d+)'&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;&lt;/div&gt;\", re.S)res = obj.finditer(s)for it in res: print(it.group('top_id'), it.group('name')) 豆瓣top250盗版天堂电影12345678910111213141516171819202122232425262728293031323334353637\"\"\"7.11 Kevin豆瓣电影排行榜top250爬虫(源代码只能进行前25个电影爬虫,通过while+params解决)\"\"\"import requestsimport reimport csvst = 0url = 'https://movie.douban.com/top250'header = ['电影名', '上映年份', '评分', '评分人数']with open(\"ranting.csv\", \"w\", encoding=\"utf-8\", newline='') as fw: writer = csv.writer(fw) writer.writerow(header)while st &lt; 250: params = {'start': st} headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36' } resp = requests.get(url, headers=headers, params=params) resp.encoding = 'utf-8' html = resp.text obj = re.compile(r'&lt;li&gt;.*?&lt;span class=\"title\"&gt;(?P&lt;name&gt;.*?)' r'&lt;/span&gt;.*?&lt;p class=\"\"&gt;.*?&lt;br&gt;(?P&lt;year&gt;.*?)&amp;nbsp' r'.*?&lt;span class=\"rating_num\" property=\"v:average\"&gt;(?P&lt;rating&gt;.*?)&lt;/span&gt;' r'.*?&lt;span&gt;(?P&lt;amount&gt;.*?)人评价&lt;/span&gt;', re.S) res = obj.finditer(html) with open(\"ranting.csv\", \"a\", encoding=\"utf-8\", newline='') as fw: writer = csv.writer(fw) for it in res: dic = it.groupdict() dic[\"year\"] = dic[\"year\"].strip() writer.writerow(dic.values()) st += 25 结果： 1234567891011121314151617181920212223242526272829303132333435363738\"\"\"7.11 Kevin爬取电影天堂2022必看电影名称，下载链接\"\"\"import requestsimport reurl = \"https://dytt89.com/\"headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36'}resp = requests.get(url, headers)resp.encoding = 'gb2312'html = resp.texturl_list = []obj1 = re.compile(r\"2022必看热片.*?&lt;ul&gt;(?P&lt;ul&gt;.*?)&lt;/ul&gt;\", re.S)obj2 = re.compile(r\"&lt;a href='(?P&lt;href&gt;.*?)'\", re.S)obj3 = re.compile(r'◎片 名(?P&lt;name&gt;.*?)&lt;br /&gt;.*?' r'&lt;td style=\"WORD-WRAP: break-word\" bgcolor=\"#fdfddf\"&gt;&lt;a href=\"(?P&lt;magnet&gt;.*?)\"&gt;', re.S)res1 = obj1.finditer(html)for it in res1: ul = it.group('ul') res2 = obj2.finditer(ul) for it2 in res2: new_url = url+it2.group('href').strip('/') url_list.append(new_url) #resp2 = requests.get(new_url, headers=headers) # resp2.encoding = 'gb2312' # res3 = obj3.finditer(resp2.text) # for it3 in res3: # print(it3.group('name'), it3.group('magnet')) # breakfor href in url_list: child_resp = requests.get(href, headers=headers) child_resp.encoding = 'gb2312' res3 = obj3.search(child_resp.text) print(res3.group('name'), res3.group('magnet'))","categories":[],"tags":[{"name":"🐍Python","slug":"🐍Python","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%8DPython/"},{"name":"🕷️爬虫","slug":"🕷️爬虫","permalink":"http://dayswithvenki.top/tags/%F0%9F%95%B7%EF%B8%8F%E7%88%AC%E8%99%AB/"}]},{"title":"Python 数据分析","slug":"Python3","date":"2022-07-10T16:00:00.000Z","updated":"2022-07-11T12:41:07.773Z","comments":true,"path":"posts/python-data-analysis.html","link":"","permalink":"http://dayswithvenki.top/posts/python-data-analysis.html","excerpt":"","text":"数据解析Requests等可以抓取整个网页，但是我们并不需要整个网页的内容，则可以通过数据提取得到需要的内容。 三种解析方式： 1.正则表达式解析 2.bs4解析 3.xpath解析 正则表达式优点: 速度快、效率高、准确性高 缺点：上手困难 正则语法：使用元字符进行排列组合用来匹配字符串，在线测试正则表达式:tool.oschina.net/regex/ 元字符: 具有固定含义的符号 常用元字符1234567891011121314151617. 匹配除换行符以外的任意字符\\w 匹配字母或数字或下划线\\s 匹配任意空白字符\\d 数字\\n 换行符\\t 制表符^ 字符串的开始$ 字符串的结尾\\W 匹配非字母或数字或下划线\\D 匹配非数字\\S 匹配非空白字符a|b a或b() 匹配括号内的表达式，也表示一个组[...] 匹配字符组中的字符[^...] 匹配除了字符组中字符的所有字符 量词：123456* 重复零次或更多次+ 重复一次或多次? 重复零次或一次{n} 重复n次{n,} 重复n次或更多次{n,m} 重复n到m次 贪婪匹配和惰性匹配:12.* 贪婪匹配.*? 惰性匹配 案例: 1234567str: 一起打游戏吗，待会打游戏吗，还是现在打游戏呢？reg: 一.*?打游戏结果: 一起打游戏reg: 一.*打游戏结果:一起打游戏吗，待会打游戏吗，还是现在打游戏","categories":[],"tags":[{"name":"🐍Python","slug":"🐍Python","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%8DPython/"},{"name":"🕷️爬虫","slug":"🕷️爬虫","permalink":"http://dayswithvenki.top/tags/%F0%9F%95%B7%EF%B8%8F%E7%88%AC%E8%99%AB/"}]},{"title":"Python Requests","slug":"Python2","date":"2022-07-07T16:00:00.000Z","updated":"2022-07-13T10:25:39.687Z","comments":true,"path":"posts/python-requests.html","link":"","permalink":"http://dayswithvenki.top/posts/python-requests.html","excerpt":"","text":"Request库getpost获取http网页的主要方法，对应http的get。 requests.get(url, params=None, **kwargs) params**kwargsResponse对象的属性一个样例另一个案例(关于需要登录的网页处理：Cookie)用于发送查询字符串，一般为字典或者字节流格式。 1234567&gt;&gt;&gt; url = 'https://www.baidu.com/s'&gt;&gt;&gt; values = { 'wd':'python'}&gt;&gt;&gt; resp = requests.get(url, params=values)&gt;&gt;&gt; resp.url'https://www.baidu.com/s?wd=python'可选参数。 属性 写法 作用 headers headers = {‘User-Agent’:xxx, ‘Cookie’:xxx, ‘Referer’:xxx} 其实这里是伪装成浏览器 header是浏览器向服务器发送的一个头信息，上面的代码就是发送了浏览器自己的型号。 auth auth = (‘username’, ‘password’) Web客户端验证参数，用于网站的用户名和密码验证。 verify verify = False/True 证书认证参数，python去访问一个没有经过CA证书认证的因特网服务类型是https的网站, 那么就会抛出一个SSLError 异常，进而我们就无法正常访问这个网站。此时！我们就可以通过设置verify参数为False，忽略证书认证，访问网站。 proxies proxies = {‘协议’:’协议://IP:端口号’} 代理IP参数，爬虫时被封IP可以使用代理IP继续爬取。 1234567891011121314151617\"\"\"7.9 Kevin爬取一个百度搜索的内容\"\"\"import requestss = input(\"请输入需要查询的内容\")#headers内容可以从控制台的Network查看headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36'}#kv的具体键值对可以通过具体网页观察urlkv = {'wd' : s}url = 'https://www.baidu.com/s'r = requests.get(url, params=kv, headers=headers)r.encoding = r.apparent_encoding #r.encoding = 'utf-8'print(r.url)print(r.text)1234567891011121314151617181920212223242526272829303132\"\"\"7.13 Kevin处理Cookie模拟用户登录1.登录 -&gt; 得到Cookie2.带着Cookie 去请求书架的url -&gt; 书架上的内容必须把以上操作连起来可以使用session进行请求 -&gt; session可以认为是一连串的请求，在这个过程中Cookie不会消失\"\"\"import requestssession = requests.session()# 1.登录url = 'https://passport.17k.com/ck/user/login'resp = session.post(url, data={'loginName': '13433947627', 'password': 'EasonChan0830'})# print(resp.cookies) # 看cookie# 2.数据处理# 刚刚的会话session中是有cookie的resp2 = session.get('https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919')print(resp2.json())# 以上可以用下面内容代替headers = { 'Cookie': 'XXX' # 从控制台Header里面复制}resp = requests.get('https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919', headers= headers)print(resp.json())向网页提交post申请的方法，对应http的post。 requests.post(url, data={key: value}, **kwargs) data可选参数属性参数一个样例字典，元组列表，字节或要发送到指定URL的文件对象。 12345&gt;&gt;&gt; url = 'https://fanyi.baidu.com'&gt;&gt;&gt; values = { 'wd':'python'}&gt;&gt;&gt; resp = requests.post(url, data=values)与get类似。与get类似。1234567891011121314\"\"\"7.9 Kevin爬取一个百度翻译的内容\"\"\"import requestss = input('请输入你需要翻译的内容\\n')params = {'kw': s}headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36'}url = 'https://fanyi.baidu.com/sug'resp = requests.post(url, data=params)print(resp.json()) 另一个实例(爬取豆瓣电影排行榜):1.进入douban.com打开控制台观察浏览器控制台的network。 2.进入Fetch/XDR观察（简化资源视图），从中找到所需的json库的url等属性，观察request method（get/post) 3.复制url，url”?”后方的可以通过payload得到，post为getdata，get为parameters，通过字典赋值可以简化url。 4.通过requests.get()/requests.post()得到resp,用resp.text测试是否爬取正常,一般反爬需要加入Headers属性，中间的User-Agent仿造浏览器访问界面。 实现代码： 123456789101112131415161718192021\"\"\"7.11 Kevin豆瓣电影排行榜爬虫\"\"\"import requestsurl = 'https://movie.douban.com/j/chart/top_list'params = { #其中start和limit属性可切换，start为排行榜的开始位数-1，limit为一次性爬取的电影数量 'type': '24', 'interval_id': '100:90', 'action': \"\", 'start': '0', 'limit': '60'}headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36'}resp = requests.get(url, params=params, headers=headers)print(resp.json())resp.close() #关闭请求","categories":[],"tags":[{"name":"🐍Python","slug":"🐍Python","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%8DPython/"},{"name":"🕷️爬虫","slug":"🕷️爬虫","permalink":"http://dayswithvenki.top/tags/%F0%9F%95%B7%EF%B8%8F%E7%88%AC%E8%99%AB/"}]},{"title":"Python 爬虫","slug":"Python1","date":"2022-07-06T16:00:00.000Z","updated":"2022-07-09T04:14:42.420Z","comments":true,"path":"posts/python-crawler.html","link":"","permalink":"http://dayswithvenki.top/posts/python-crawler.html","excerpt":"","text":"一些关键信息请求头的关键信息1.User-Agent：请求载体的身份识别。（用什么发的请求） 2.Referer：防盗链。（请求的页面来源） 3.Cookie：本地字符串数据信息。（用户登录信息，反爬的token） 请求方式1.get 2.post 响应头的关键信息1.Cookie：本地字符串数据信息。（用户登录信息，反爬的token） 2.一些奇怪的字符串（一般是token字样，防止攻击和反爬） 得到页面源代码可用库:123import requests#from urllib.request import urlopen urlopen用法123url = 'https://www.baidu.com'resp = urlopen(url)print(resp.read().decode('utf-8'))#用utf-8解码得到页面源代码 request库用法123456789101112131415url = 'https://www.baidu.com/s'#请求头关键信息,可通过f12查看headers = { 'User-Agent':'' 'Cookie':'' 'Referer':''}params = { 'wd' : 'python'}#连接在url后方的:如www.baidu.com/s?resp = requests.get(url, params=params, headers=headers)resp.encoding = 'utf-8'#将resp的编码改为utf-8print(resp.text) #得到页面源代码print(resp.url) #得到页面的url连接，当前为https://www.baidu.com/s?wd=python","categories":[],"tags":[{"name":"🐍Python","slug":"🐍Python","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%8DPython/"},{"name":"🕷️爬虫","slug":"🕷️爬虫","permalink":"http://dayswithvenki.top/tags/%F0%9F%95%B7%EF%B8%8F%E7%88%AC%E8%99%AB/"}]},{"title":"计算机网络1","slug":"计算机网络 第二章","date":"2022-04-25T08:50:23.606Z","updated":"2022-07-02T06:42:34.573Z","comments":true,"path":"posts/net1.html","link":"","permalink":"http://dayswithvenki.top/posts/net1.html","excerpt":"","text":"公式: 奈氏准则: 码元传输的最高速率 = 2W (码元/s) 信噪比(dB) = 10\\log_{10}{S/N} (dB) 香农公式: C = W\\log_2{(1+S/N)} (bit/s) W为信道宽度,S为信道内所传信号的平均功率,N为信道内部高斯噪声功率. 意义: 奈氏准则:激励不断探索先进的编码技术,是每一个码元携带更多比特的信息. 香农公式:告诫不可能突破信息传输速率的绝对极限. CDMA工作原理: &nbsp;&nbsp;1.将每一个比特时间划分为m个短的间隔,称为码片. &nbsp;&nbsp;2.为每个站指派一个唯一的m bit码片序列. ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)发送比特1: 发送自己的m位码片序列. ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)发送比特0: 发送该码片序列的二进制反码. eg: S的8 bit 码片序列为 00011011. 1 -&gt; 00011011 0 -&gt; 11100100 码片序列: (-1 -1 -1 +1 +1 -1 +1 +1) 每个站分配的码片序列：各不相同，且必须互相正交。 正交：向量 S和T的规格化内积 等于0 。 任何一个码片向量和该码片向量自己的规格化内积都是1 。 一个码片向量和该码片反码的向量的规格化内积值是-1。","categories":[],"tags":[]},{"title":"像素插画2","slug":"Genshin","date":"2022-04-17T11:16:29.252Z","updated":"2022-07-13T07:05:59.472Z","comments":true,"path":"posts/genshin.html","link":"","permalink":"http://dayswithvenki.top/posts/genshin.html","excerpt":"","text":"像素插画2 胡桃: 甘雨: 魈: 宵宫: 神里: 万叶:","categories":[{"name":"插画","slug":"插画","permalink":"http://dayswithvenki.top/categories/%E6%8F%92%E7%94%BB/"}],"tags":[{"name":"🎨像素画","slug":"🎨像素画","permalink":"http://dayswithvenki.top/tags/%F0%9F%8E%A8%E5%83%8F%E7%B4%A0%E7%94%BB/"}]},{"title":"阅读方法","slug":"01.阅读方法","date":"2022-04-11T14:39:18.179Z","updated":"2022-07-13T06:23:58.921Z","comments":false,"path":"posts/english1.html","link":"","permalink":"http://dayswithvenki.top/posts/english1.html","excerpt":"","text":"01.阅读方法 一、先题后文，再看题干，不看选项 why?(先题后文) 1.解题 2.串联题干 -&gt; 预判主旨~（题干中反复提到）~3.通读全文 二、 做阅读理解除了翻译外，需要关注: 1.感情色彩强烈的词: adj,adv,n(系动词之后) [认识单词!!] [真题] 1. 最经常出现的词有Job，但是容易忽略agent。（不能顾此失彼） job&lt;-&gt;agent关系: &nbsp;&nbsp; 第4题: agent offer each job hunter… options. 2. 虽然一般不看选项，但是若选项中有共有的信息,则不为干扰信息为正确信息。 如本题: Women/Stress，有助于帮助判断（提示）中心思想。 1.串联题干 2.通读全文 3.the best title (读一段做一题∵题文同序) 不熟或者不认识的词汇: predominance 统治地位 manifest 显示 revival 进步、振兴","categories":[],"tags":[{"name":"📖考研英语","slug":"📖考研英语","permalink":"http://dayswithvenki.top/tags/%F0%9F%93%96%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD/"}]},{"title":"美化记录","slug":"美化记录","date":"2022-03-28T06:44:25.000Z","updated":"2022-07-09T03:46:37.720Z","comments":true,"path":"posts/butterfly.html","link":"","permalink":"http://dayswithvenki.top/posts/butterfly.html","excerpt":"","text":"美化记录TOC无法跳转问题预览效果 无 参考文档 侧边栏BOTUI预览效果 参考文档 文章置顶轮换栏预览效果 参考文档 侧边栏碎碎念+页面碎碎念Artitalk Pro预览效果 参考文档 标签外挂预览效果 无 参考文档 右键菜单预览效果 参考文档 作者介绍预览效果 参考文档 首页磁贴预览效果 参考文档 Custom Beautify内容记录 ·阿里IconFont引入 ·侧边栏透明 ·公告小人 ·页脚不同时间不同显示的柴柴 ·页脚皮卡丘 ·网站各种像素画 ·文字/图标颜色自定义，字体像素风 ·加载动画: Loading/日夜转换 ·夜间模式背景流星","categories":[{"name":"HEXO","slug":"HEXO","permalink":"http://dayswithvenki.top/categories/HEXO/"}],"tags":[{"name":"🦋Butterfly","slug":"🦋Butterfly","permalink":"http://dayswithvenki.top/tags/%F0%9F%A6%8BButterfly/"}]},{"title":"算法课笔记2","slug":"algorithm3","date":"2022-03-25T15:52:40.000Z","updated":"2022-07-06T02:02:53.558Z","comments":false,"path":"posts/algorithm3.html","link":"","permalink":"http://dayswithvenki.top/posts/algorithm3.html","excerpt":"","text":"数学预备知识 典型求和公式 1.\\sum_{i=1}^{n} i=n(n+1)/2=\\Theta(n^2) 2.\\sum_{i=1}^{n} (a+bi)=na+bn(n+1)/2=\\Theta(n^2) 3.\\sum_{i=1}^{n} i^2 = \\frac{n(n+1)(2n+1)}{6} =\\Theta(n^3) 4.\\sum_{i=1}^{n} i^k = \\Theta (n^k +1) 5.\\sum_{i=1}^{n} a^i = \\frac{1-a^{n+1}}{1-a}=\\Theta (a^n) ,(a \\neq 1) 特别的： 6.\\sum_{i=1}^{n} a^i = 1/(1-a) , (|a| < 1) 7.\\sum_{i=1}^{\\infty} a^i = \\Theta (1) , (|a| < 1) 8.\\sum_{i=1}^{n} ia^i = \\Theta (na^n) ,(a \\neq 1) 积分图像求边界 条形图是\\sum,曲线是\\int 如果f(x)是单调递减的，则： \\int_{m}^{n+1} f(x) dx \\leq \\sum_{j=m}^{n}f(j) \\leq \\int_{m-1}^n f(x)dx如果f(x)是单调递增的，则： \\int_{m-1}^{n} f(x) dx \\leq \\sum_{j=m}^{n}f(j) \\leq \\int_{m}^{n+1} f(x)dx","categories":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://dayswithvenki.top/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"🖥️算法设计与分析","slug":"🖥️算法设计与分析","permalink":"http://dayswithvenki.top/tags/%F0%9F%96%A5%EF%B8%8F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}]},{"title":"算法课笔记1","slug":"algorithm2","date":"2022-03-25T02:43:40.000Z","updated":"2022-07-07T08:26:04.843Z","comments":false,"path":"posts/algorithm2.html","link":"","permalink":"http://dayswithvenki.top/posts/algorithm2.html","excerpt":"","text":"1.时间复杂性 最优算法: 时间复杂性O(n log n),空间复杂性O(1) 1)$O$符号(上界) 令f(n)和g(n)是从自然数集到非负实数集的两个函数，若存在一个自然数n_{0}和一个常数c&gt;0，使得: {\\forall}n\\geq n_{0},f(n)\\leq cg(n)则f(n)为$O$(g(n))。 若&nbsp;&nbsp;\\lim_{n\\to \\infty}\\frac{f(n)}{g(n)} 存在 那么: \\lim_{n\\to\\infty}\\frac{f(n)}{g(n)}\\neq \\infty 则: f(n)=O(g(n)) 2)$\\Omega$符号(下界) 令f(n)和g(n)是从自然数集到非负实数集的两个函数，若存在一个自然数n_{0}和一个常数c&gt;0，使得: {\\forall}n\\geq n_{0},f(n)\\geq cg(n)则f(n)为$\\Omega$(g(n))。 若&nbsp;&nbsp;\\lim_{n\\to \\infty}\\frac{f(n)}{g(n)} 存在 那么: \\lim_{n\\to\\infty}\\frac{f(n)}{g(n)}\\neq0则 f(n)=Ω(g(n)) 3)$\\Theta$符号 令f(n)和g(n)是从自然数集到非负实数集的两个函数，若存在一个自然数$n_{0}$和常数$c_1,c_2$使得: {\\forall}n\\geq n_{0}, c_1g(n)\\leq f(n) \\leq c_2g(n)则f(n)为$\\Theta$(g(n))。 若&nbsp;&nbsp;\\lim_{n\\to \\infty}\\frac{f(n)}{g(n)} 存在 那么: \\lim_{n\\to\\infty}\\frac{f(n)}{g(n)}=c则 f(n)=\\Theta(g(n))\\quad\\quad(其中c\\geq 0)Summary: 可以认为$O$类似于 $\\leq$, $\\Omega$类似于$\\geq$,$\\Theta$类似于= 举例: $f(n)=\\log{n^2}$ $$ \\because \\lim_{n\\to\\infty}\\frac{\\log{n^2}}{n}=\\lim_{n\\to\\infty}\\frac{2\\log{n}}{n}=\\frac{2}{\\ln{2}}\\lim_{n\\to\\infty}\\frac{1}{n}=0 \\\\\\\\ $$ $$ \\therefore f(n)=O(n)\\quad but \\quad not \\quad \\Omega(n) or \\Theta(n) $$ $$ \\because \\log{n^2}=2\\log{n} \\therefore\\log{n^2}=\\Theta(\\log{n}) \\\\\\\\ \\therefore \\log{n^k}=\\Theta(n)\\\\ $$ $ \\sum_{j=1}^{n}\\log{j}$ $$ \\because \\sum_{j=1}^{n}\\log{j} \\leq \\sum_{j=1}^{n}\\log{n} $$ $$ \\therefore \\sum_{j=1}^{n}\\log{j} = O(n\\log{n}) $$ $$ 又 \\because \\sum_{j=1}^{n}\\log{j} \\geq \\sum_{j=1}^{\\frac{n}2}\\log{\\frac{n}2}=\\frac{n}{2}\\log{\\frac{n}2}=\\frac{n}{2}\\log{n} -\\frac{n}{2} $$ $$ \\therefore \\sum_{j=1}^{n} = \\Omega(n\\log{n}) $$ $$ \\therefore \\sum_{j=1}^{n} = \\Theta(n\\log{n}) $$ $\\log{n!}$ $$ \\because \\log{n!}=\\log({n*(n-1)*\\dots*1})=\\log n *\\log(n-1) *\\dots*\\log 1=\\sum_{j=1}^{n}\\log j $$ $$ \\therefore \\log n! = \\Theta (n\\log n) $$ 3)$o$符号 f(n)=o(g(n))当且仅当f(n)=O(g(n)),g(n)\\neq O(g(n))用f(n)$\\prec$g(n)表示f(n)是o(g(n))的： 1 \\prec \\log \\log n \\prec \\log n\\prec \\sqrt n \\prec n^{\\frac3 4}\\prec n\\prec n\\log n \\prec n^2 \\prec n! \\prec2^{n^2}","categories":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://dayswithvenki.top/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"🖥️算法设计与分析","slug":"🖥️算法设计与分析","permalink":"http://dayswithvenki.top/tags/%F0%9F%96%A5%EF%B8%8F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}]},{"title":"LaTeX语法(下)","slug":"LateX语法下","date":"2022-03-24T11:17:31.982Z","updated":"2022-07-06T02:08:49.090Z","comments":false,"path":"posts/latex2.html","link":"","permalink":"http://dayswithvenki.top/posts/latex2.html","excerpt":"","text":"LateX语法 由于内容过多,分为两篇来写 上一篇 http://dayswithvenki.top/posts/latex1.html 7)箭头符号: ​ \\leftarrow , \\rightarrow ,\\leftrightarrow,\\longleftarrow,\\longleftrightarrow,\\longrightarrow \\Longleftarrow,\\Longleftrightarrow,\\Longrightarrow \\leftarrow , \\rightarrow ,\\leftrightarrow,\\longleftarrow,\\longleftrightarrow,\\longrightarrow \\Longleftarrow,\\Longleftrightarrow,\\Longrightarrow箭头上加内容: \\xleftarrow和\\xrightarrow可根据内容自动调整 \\xleftarrow{x,y,z} 和 \\xrightarrow{x,y,z} 8)注音和标注 \\bar{x}, \\acute{x}, \\mathring{x}, \\vec{x}, \\grave{x}, \\breve{x}, \\hat{x}, \\tilde{x} \\dot{x}, \\ddot{x} , \\dddot{x} \\bar{x}, \\acute{x}, \\mathring{x}, \\vec{x}, \\grave{x}, \\breve{x}, \\hat{x}, \\tilde{x},\\dot{x}, \\ddot{x} , \\dddot{x} 9)分隔符 \\overline{xxx}, \\overleftrightarrow{xxx}, \\underline{xxx}, \\underleftrightarrow{xxx}, \\overleftarrow{xxx}, \\overbrace{xxx}, \\underleftarrow{xxx}, \\underbrace{xxx}, \\overrightarrow{xxx}, \\widehat{xxx}, \\underrightarrow{xxx}, \\widetilde{xxx} \\overline{xxx},\\overleftrightarrow{xxx},\\underline{xxx},\\underleftrightarrow{xxx} \\overleftarrow{xxx}, \\overbrace{xxx}, \\underleftarrow{xxx}, \\underbrace{xxx} \\overrightarrow{xxx}, \\widehat{xxx}, \\underrightarrow{xxx}, \\widetilde{xxx} 10)省略号 省略号用 \\dots \\cdots \\vdots \\ddots表示 ，\\dots和\\cdots的纵向位置不同，前者一般用于有下标的序列 1$$ x_1, x_2, \\dots, x_n\\quad 1,2,\\cdots,n\\quad \\vdots\\quad \\ddots $$ x_1, x_2, \\dots, x_n\\quad 1,2,\\cdots,n\\quad \\vdots\\quad \\ddots 11)空白间距 语法 格式 实例 显示 quad空格 a \\quad b 一个m的宽度 两个quad空格 a \\qquad b 两个m的宽度 大空格 a \\: b 1/3m宽度 中等空格 a \\; b 2/7m宽度 小空格 a \\, b 1/6m宽度 没有空格 ab 没有空格 缩进空格 a \\! b 缩进1/6m宽度 12)矩阵 1234567$$\\begin{array}{ccc}x_1 &amp; x_2 &amp;\\dots\\\\x_3 &amp; x_4 &amp;\\dots\\\\\\vdots&amp;\\vdots&amp;\\ddots\\end{array}$$ \\begin{array}{ccc} x_1 & x_2 &\\dots\\\\ x_3 & x_4 &\\dots\\\\ \\vdots&\\vdots&\\ddots \\end{array}123456789101112131415161718192021222324252627$$\\begin{pmatrix} a &amp; b\\\\ c &amp; d \\\\\\end{pmatrix}\\quad\\begin{bmatrix} a &amp; b \\\\ c &amp; d \\\\\\end{bmatrix}\\quad\\begin{Bmatrix} a &amp; b \\\\ c &amp; d \\\\\\end{Bmatrix}\\quad\\begin{vmatrix} a &amp; b \\\\ c &amp; d \\\\\\end{vmatrix}\\quad\\begin{Vmatrix} a &amp; b \\\\ c &amp; d \\\\\\end{Vmatrix}$$ \\begin{pmatrix} a & b\\\\ c & d \\\\ \\end{pmatrix} \\quad \\begin{bmatrix} a & b \\\\ c & d \\\\ \\end{bmatrix} \\quad \\begin{Bmatrix} a & b \\\\ c & d \\\\ \\end{Bmatrix} \\quad \\begin{vmatrix} a & b \\\\ c & d \\\\ \\end{vmatrix} \\quad \\begin{Vmatrix} a & b \\\\ c & d \\\\ \\end{Vmatrix}以下渲染均出现问题 已解决,渲染引擎将\\ _等符号自动转义成html语法。 把’\\\\’写成’\\\\\\\\’即可 将渲染引擎从hexo-renderer-marked \\stackrel{转换}{\\longrightarrow}hexo-renderer-kramed 13)长公式 123456$$\\begin{multline} x = a+b+c+{} \\\\ d+e+f+g \\end{multline}$$ \\begin{multline} x = a+b+c+{} \\\\ d+e+f+g \\end{multline}123456$$\\begin{split}x = {} &amp; a + b + c +{}\\\\ &amp; d + e + f + g\\end{split}$$ \\begin{split} x = {} & a + b + c +{}\\\\ & d + e + f + g \\end{split} 14)公式组 123456$$\\begin{align}a &amp;=b+c+d \\\\x &amp;=y+z \\\\5 &amp;= 4+1\\end{align}$$ \\begin{align} a &=b+c+d\\\\ x &=y+z\\\\ 5 &= 4+1 \\end{align} 15)分支公式 1234$$ y=\\begin{cases}-x,\\quad x\\leq 0\\\\x, \\quad x&gt;0\\end{cases} $$ y= \\begin{cases} -x, \\quad x\\leq 0 \\\\ x, \\quad x>0 \\end{cases}","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://dayswithvenki.top/categories/MarkDown/"}],"tags":[{"name":"👾LaTeX","slug":"👾LaTeX","permalink":"http://dayswithvenki.top/tags/%F0%9F%91%BELaTeX/"}]},{"title":"LaTeX语法(上)","slug":"LateX语法上","date":"2022-03-24T08:43:10.790Z","updated":"2022-07-06T02:08:52.122Z","comments":false,"path":"posts/latex1.html","link":"","permalink":"http://dayswithvenki.top/posts/latex1.html","excerpt":"","text":"LateX语法 参考文献:https://www.jianshu.com/p/8c46e915c45e 由于内容过多,分为两篇来写 下一篇 http://dayswithvenki.top/posts/latex2.html 一、 MarkDown 排版格式 块公式排版 1$$c = \\sqrt{a^{2}+b_{xy}^2+e^{x}} $$ eg: c = \\sqrt{a^{2}+b_{xy}^2+e^{x}} 二、LaTeX的公式规则 1)转义 以下几个字符:# $ % &amp; ~ _ ^ { }有特殊意义，需要表示这些字符时，需要转义，即在每个字符前加上 \\ 。eg: \\boxed命令给公式加一个方框。 123$$E=mc^2\\quad 与 \\quad\\boxed{E=mc^2}$$ E=mc^2 \\quad与\\quad \\boxed{E=mc^2}\\quad 表示空格 2)希腊字母 希腊字母 LaTeX 希腊字母 LaTeX α \\alpha ν \\nu β \\beta ξ \\xi \\Xi γ \\gamma ο \\omicron δ \\delta π \\pi ε \\varepsilon ρ \\rho ζ \\zeta σ,∑ \\sigma \\Sigma η \\eta τ \\tau θ \\theta υ \\upsilon ι \\iota ϕ,φ,Φ \\phi \\varphi \\Phi κ \\kappa χ \\chi λ \\lambda ψ,Ψ \\psi \\Psi μ \\mu ω,Ω \\omega \\Omega 3) 上下标、根号 用^来表示上标用_来表示下标用\\sqrt表示根号 上下标如果多余一个字符或者符号，需要用{}括起来。 开方写法: \\sqrt[开方次数,默认为2]{开方式子} eg: 1$$ \\sum_{i=1}^n a_i $$ \\sum_{i=1}^n a_i1$$ \\sqrt{x}\\quad \\sqrt[3]{x} $$ \\sqrt{x}\\quad \\sqrt[3]{x} 4)分数 分数用\\frac表示 1$$ \\frac{1}{2}$$ \\frac{1}{2} 5)运算符 特殊运算则用以下特殊命令\\pm\\; \\times\\; \\div\\; \\cdot\\; \\cap\\; \\cup\\; \\geq\\; \\leq\\; \\neq\\; \\approx\\; \\equiv \\pm\\ \\times\\ \\div\\ \\cdot\\ \\cap\\ \\cup\\ \\geq\\ \\leq\\ \\neq\\ \\approx\\ \\equiv\\ 和、积、极限、积分 \\sum \\prod \\lim \\int \\sum \\quad \\prod \\quad \\lim \\quad \\int 12345678910$$ \\sum_{i=1}^n i \\quad\\prod_{i=1}^n \\quad\\lim_{x\\to0}x^2 \\quad\\int_{a}^{b}x^2 dx \\quad \\sum_{i=1}^n i \\quad\\prod_{i=1}^n \\quad\\lim_{x\\to0}x^2 \\quad\\int_{a}^{b}x^2 dx$$ \\sum_{i=1}^n i \\quad \\prod_{i=1}^n \\quad \\lim_{x\\to0}x^2 \\quad \\int_{a}^{b}x^2 dx \\quad \\sum_{i=1}^n i \\quad \\prod_{i=1}^n \\quad \\lim_{x\\to0}x^2 \\quad \\int_{a}^{b}x^2 dx 6)多重积分 使用如下形式: \\int 、\\iint 、\\iiint 、\\iiiint 、 \\idotsint \\int \\quad \\iint \\quad \\iiint \\quad \\idotsint","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://dayswithvenki.top/categories/MarkDown/"}],"tags":[{"name":"👾LaTeX","slug":"👾LaTeX","permalink":"http://dayswithvenki.top/tags/%F0%9F%91%BELaTeX/"}]},{"title":"三角函数图像关系","slug":"图像关系","date":"2022-03-14T02:08:26.000Z","updated":"2022-07-06T02:04:44.820Z","comments":false,"path":"posts/91357ab4.html","link":"","permalink":"http://dayswithvenki.top/posts/91357ab4.html","excerpt":"","text":"图片来源:https://blog.csdn.net/qq_40828914/article/details/105929384 123456789101112131415161718192021221.倒三角：sin²+cos²=1tan²+1=sec²1+cot²=csc²2.对角线倒数3.邻点积tan*cos=sinsin*cot=cos4.求导:左三角导数正，右三角导数负上互换：sin'=coscos'=-sin中下2：tan'=sec²cot'=-csc²下中下：sec'=tan*seccsc=-cot*csc5.求积分：sec积分：ln|sec+tan|+Ccsc积分：-ln|csc+cot|+C 三角函数及其倒数的图像 sin x &amp; csc x cos x &amp; sec x tan x &amp; cot x 三角函数及其反函数的图像 sin x &amp; arcsin x cos x &amp; arccos x tan x &amp; arctan x 函数及其反函数图像关于y=x对称","categories":[{"name":"三角函数","slug":"三角函数","permalink":"http://dayswithvenki.top/categories/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"🧮三角函数","slug":"🧮三角函数","permalink":"http://dayswithvenki.top/tags/%F0%9F%A7%AE%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"}]},{"title":"三角函数求导","slug":"函数求导","date":"2022-03-14T00:55:19.000Z","updated":"2022-07-06T02:04:36.113Z","comments":false,"path":"posts/91357ab3.html","link":"","permalink":"http://dayswithvenki.top/posts/91357ab3.html","excerpt":"","text":"注：三角函数的导数=1/反三角函数导数的倒数(需要注意替换x,y) eg: sin x和 arcsin x ​ 三角函数 反三角函数","categories":[{"name":"三角函数","slug":"三角函数","permalink":"http://dayswithvenki.top/categories/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"🧮三角函数","slug":"🧮三角函数","permalink":"http://dayswithvenki.top/tags/%F0%9F%A7%AE%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"}]},{"title":"小郭的像素插画","slug":"show","date":"2022-03-10T16:12:03.948Z","updated":"2022-07-14T05:32:55.389Z","comments":true,"path":"posts/17ff13214.html","link":"","permalink":"http://dayswithvenki.top/posts/17ff13214.html","excerpt":"","text":"小郭的像素插画 See more in Pixilart of Kevin https://www.pixilart.com/kevin-venki future: Kevin: Venki: chaichai: mimao:","categories":[{"name":"插画","slug":"插画","permalink":"http://dayswithvenki.top/categories/%E6%8F%92%E7%94%BB/"}],"tags":[{"name":"🎨像素画","slug":"🎨像素画","permalink":"http://dayswithvenki.top/tags/%F0%9F%8E%A8%E5%83%8F%E7%B4%A0%E7%94%BB/"}]},{"title":"三角函数与反三角函数","slug":"三角函数与反三角函数","date":"2022-03-06T02:11:53.000Z","updated":"2022-07-06T02:05:31.883Z","comments":false,"path":"posts/91357ab2.html","link":"","permalink":"http://dayswithvenki.top/posts/91357ab2.html","excerpt":"","text":"三角函数 二倍角公式(逆推可以得到半角公式) 和差化积！！！ 注意：此处第一条sin的公式，左右两边正负号相反。!!! (即：三个符号分别为：+ + - / - - +) !!! 积化和差！！！ 反三角函数 主要的反三角函数以及图像(注意值域与定义域) 反三角函数公式(!!注意2和3的区别) -x的反三角函数与x的三角函数的关系 反三角函数的三角函数 三角函数的反三角函数","categories":[{"name":"三角函数","slug":"三角函数","permalink":"http://dayswithvenki.top/categories/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"🧮三角函数","slug":"🧮三角函数","permalink":"http://dayswithvenki.top/tags/%F0%9F%A7%AE%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"}]},{"title":"算法设计与分析第一次习题","slug":"algorithm1","date":"2022-03-03T08:17:17.000Z","updated":"2022-07-06T02:03:42.816Z","comments":false,"path":"posts/algorithm1.html","link":"","permalink":"http://dayswithvenki.top/posts/algorithm1.html","excerpt":"","text":"斐波那契数列（I） 已知斐波那契数列 Fn=Fn−1+Fn−2(n&gt;=3),F1=1,F2=1 用递归的方法求解该数列的第n项。 输入格式: 输入一个正整数n (1&lt;=n&lt;=40)。 输出格式: 输出一个数，数列的第n项。 输入样例 11 输出样例 13 代码示例 1234567891011121314151617#include &lt;iostream&gt;#define maxSize 40using namespace std;int Fib(int n){ if(n==1||n==2) return 1; else{ return Fib(n-2)+Fib(n-1); }}int main(){ int n; cin&gt;&gt;n; cout&lt;&lt;Fib(n)&lt;&lt;endl; return 0;} 斐波那契数列（II） 已知已知斐波那契数列 Fn=Fn−1+Fn−2(n&gt;=3),F1=1,F2=1 求解该数列的第n项，结果对998244353取模。 输入格式: 输入一个正整数n (1&lt;=n&lt;=40)。 输出格式: 输出一个数，数列的第n项。 输入样例 11 输出样例 13 代码示例 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;#define N 998244353int main(){ int n; int f1=1,f2=1,ans=0; int fn; cin&gt;&gt;n; if(n==1||n==2) ans=1; else{ for(int i=3;i&lt;=n;i++){ fn=(f1+f2)%N; f2=f1; f1=fn; } ans=fn; } cout&lt;&lt;ans; return 0;} 最大公约数和最小公倍数 本题要求两个给定正整数的最大公约数和最小公倍数。 输入格式: 输入在一行中给出两个正整数M和N（≤1000）。 输出格式: 在一行中顺序输出M和N的最大公约数和最小公倍数，两数字间以1空格分隔。 输入样例 1511 292 输出样例 173 2044 代码示例 12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;gcd(n,m)&lt;&lt;\" \"&lt;&lt;lcm(n,m)&lt;&lt;endl; return 0;} 打印选课学生名单 假设全校有最多40000名学生和最多2500门课程。现给出每个学生的选课清单，要求输出每门课的选课学生名单。 输入格式: 输入的第一行是两个正整数：N（≤40000），为全校学生总数；K（≤2500），为总课程数。此后N行，每行包括一个学生姓名（3个大写英文字母+1位数字）、一个正整数C（≤20）代表该生所选的课程门数、随后是C个课程编号。简单起见，课程从1到K编号。 输出格式: 顺序输出课程1到K的选课学生名单。格式为：对每一门课，首先在一行中输出课程编号和选课学生总数（之间用空格分隔），之后在第二行按字典序输出学生名单，每个学生名字占一行。 输入样例 123456789101110 5ZOE1 2 4 5ANN0 3 5 2 1BOB5 5 3 4 2 1 5JOE4 1 2JAY9 4 1 2 5 4FRA8 3 4 2 5DON2 2 4 5AMY7 1 5KAT3 3 5 4 2LOR6 4 2 4 1 5 输出样例 123456789101112131415161718192021222324252627282930313233341 4ANN0BOB5JAY9LOR62 7ANN0BOB5FRA8JAY9JOE4KAT3LOR63 1BOB54 7BOB5DON2FRA8JAY9KAT3LOR6ZOE15 9AMY7ANN0BOB5DON2FRA8JAY9KAT3LOR6ZOE1 代码示例 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;struct node{ char name[5];}course[2510][40000];int num[2510]; bool cmp(node a,node b){ return strcmp(a.name,b.name)&lt;0;}int main(){ int n, k; cin&gt;&gt;n&gt;&gt;k; int i, j; for(i = 0; i &lt; n; i++) { char name[5]; cin&gt;&gt;name; int c; cin&gt;&gt;c; int id; for(j = 0; j &lt; c; j++) { cin&gt;&gt;id; strcpy(course[id][num[id]++].name, name); } } for(i = 1; i &lt;= k; i++) { sort(course[i], course[i] + num[i], cmp);//字典序排序 } for(i = 1; i &lt;= k; i++) { cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;num[i]&lt;&lt;endl; for(j = 0; j &lt; num[i]; j++) { printf(\"%s\\n\", course[i][j].name); //cout&lt;&lt;course[i][j].name&lt;&lt;endl; } } return 0;} 两个有序链表序列的交集 已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。 输入格式: 输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。。 输出格式: 在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。 输入样例 121 2 5 -12 4 5 8 10 -1 输出样例 12 5 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#define maxSize 1000using namespace std;struct Node { int data; Node* next; Node() :data(0),next(NULL){} Node(int num) :data(num),next(NULL) {}};class LinkList {public: Node* first; LinkList() {first = new Node(); } void CreateList(int val); void Insert(int val); void show();};void LinkList::CreateList(int val) { Node* newNode, * last=first; int d; while (cin &gt;&gt; d &amp;&amp; d != val) { if (first-&gt;next == NULL) { newNode = new Node(d); first-&gt;next = newNode; last = newNode; } else { newNode = new Node(d); last-&gt;next = newNode; last = newNode; } }}void LinkList::show() { Node* cur = first; while (cur-&gt;next != NULL) { cur = cur-&gt;next; if (cur-&gt;next == NULL) cout &lt;&lt; cur-&gt;data; else cout &lt;&lt; cur-&gt;data &lt;&lt; \" \"; } if (first-&gt;next == NULL) cout &lt;&lt; \"NULL\" &lt;&lt; endl;}void LinkList::Insert(int val) { Node* newNode = new Node(val); Node* cur = first; while (cur-&gt;next != NULL) cur = cur-&gt;next; cur-&gt;next = newNode;}void CompareListNode(LinkList s1, LinkList s2, LinkList s3) { Node* a = s1.first-&gt;next, * b = s2.first-&gt;next; while (a &amp;&amp; b) { if ((a-&gt;data) &lt; (b-&gt;data)) a = a-&gt;next; else if ((a-&gt;data) &gt; (b-&gt;data)) b = b-&gt;next; else if ((a-&gt;data) == (b-&gt;data)) { s3.Insert(a-&gt;data); a = a-&gt;next; b = b-&gt;next; } }}int main() { LinkList s1, s2,s3; s1.CreateList(-1); s2.CreateList(-1); CompareListNode(s1, s2, s3); s3.show(); return 0;} 人以群分 社交网络中我们给每个人定义了一个“活跃度”，现希望根据这个指标把人群分为两大类，即外向型（outgoing，即活跃度高的）和内向型（introverted，即活 跃度低的）。要求两类人群的规模尽可能接近，而他们的总活跃度差距尽可能拉开。 输入格式: 输入第一行给出一个正整数N（2≤N≤10^5)。随后一行给出N个正整数，分别是每个人的活跃度，其间以空格分隔。题目保证这些数字以及它们的和都不会超过2^31。 输出格式: 123Outgoing #: N1Introverted #: N2Diff = N3 其中N1是外向型人的个数；N2是内向型人的个数；N3是两群人总活跃度之差的绝对值。 输入样例 121023 8 10 99 46 2333 46 1 666 555 输出样例 123Outgoing #: 5Introverted #: 5Diff = 3611 代码示例 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define maxSize 100000using namespace std;typedef long long ll;int compare(const void* a, const void* b){ return (*(ll*)a - *(ll*)b);}int main() { int n;ll og = 0, it = 0; ll* a = new ll[maxSize]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; } qsort(a,n,sizeof(ll),compare); if (n%2) { for (int i = 0; i &lt; n; i++) { if (i &lt; n / 2) it += a[i]; else og += a[i]; } cout &lt;&lt; \"Outgoing #: \" &lt;&lt; n/2+1 &lt;&lt; endl; cout &lt;&lt; \"Introverted #: \" &lt;&lt; n/2 &lt;&lt; endl; cout &lt;&lt; \"Diff = \" &lt;&lt; og - it &lt;&lt; endl; } else { for (int i = 0; i &lt; n; i++) { if (i &lt; n / 2) it += a[i]; else og += a[i]; } cout &lt;&lt; \"Outgoing #: \" &lt;&lt; n / 2 &lt;&lt; endl; cout &lt;&lt; \"Introverted #: \" &lt;&lt; n / 2 &lt;&lt; endl; cout &lt;&lt; \"Diff = \" &lt;&lt; og - it &lt;&lt; endl; } return 0;} 公路村村通 现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。 输入格式: 输入数据包括城镇数目正整数N（≤1000）和候选道路数目M（≤3N）；随后的M行对应M条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到N编号。 输出格式: 输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。 输入样例 123456789101112131415166 151 2 51 3 31 4 71 5 41 6 22 3 42 4 62 5 22 6 63 4 63 5 13 6 14 5 104 6 85 6 3 输出样例 112 代码示例1还在做...","categories":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://dayswithvenki.top/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[{"name":"🖥️算法设计与分析","slug":"🖥️算法设计与分析","permalink":"http://dayswithvenki.top/tags/%F0%9F%96%A5%EF%B8%8F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"⌨️PTA","slug":"⌨️PTA","permalink":"http://dayswithvenki.top/tags/%E2%8C%A8%EF%B8%8FPTA/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2022-03-01T15:17:45.865Z","updated":"2022-07-02T06:58:28.579Z","comments":false,"path":"posts/33f59116.html","link":"","permalink":"http://dayswithvenki.top/posts/33f59116.html","excerpt":"","text":"- -hexo s- hexo s &lt;/div&gt; 启动本地服务器，默认：http://localhost::4000/ - hexo s 是 hexo server 的缩写，命令效果一致； - 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可； 对 Hexo 根目录 _config.yml 的修改，需要重启本地服务器后才能预览效果。 --- -hexo n- `` hexo n \"new test\"`` 新建一篇标题为 new test 的文章，因为标题里有空格，所以加上了引号。 - 文章标题可以在对应 md 文件里改，新建时标题可以写的简单些； hexo n 是 hexo new 的缩写，命令效果一致。 -hexo d- ``hexo d`` 自动生成网站静态文件，并部署到设定的仓库。 - 文章标题可以在对应 md 文件里改，新建时标题可以写的简单些； hexo d 是 hexo deploy 的缩写，命令效果一致。 -hexo clean- ``hexo clean`` 清除缓存文件 db.json 和已生成的静态文件 public。 -网站显示异常时可以执行这条命令试试。 --- -hexo g- ``hexo g`` 生成网站静态文件到默认设置的 public 文件夹。 -便于查看网站生成的静态文件或者手动部署网站； -如果使用自动部署，不需要先执行该命令； -hexo g 是 hexo generate 的缩写，命令效果一致。 --- -hexo n page- ``hexo n page aboutme`` 新建一个标题为 aboutme 的页面， 默认链接地址为 主页地址/aboutme/ -标题可以为中文，但一般习惯用英文； -页面标题和文章一样可以随意修改； -页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。 --- 常用组合 ``hexo clean &amp;&amp; hexo s`` ``hexo clean &amp;&amp; hexo d`` 更多请参照 官方文档&lt;/h1&gt;","categories":[{"name":"HEXO","slug":"HEXO","permalink":"http://dayswithvenki.top/categories/HEXO/"}],"tags":[]},{"title":"小酒窝","slug":"songtest","date":"2022-03-01T15:17:45.856Z","updated":"2022-07-02T06:57:29.089Z","comments":false,"path":"posts/17ffbd8e.html","link":"","permalink":"http://dayswithvenki.top/posts/17ffbd8e.html","excerpt":"","text":"小酒窝 12345include &lt;bits/stdc++.h&gt;using namespace std;int main(){ cout&lt;&lt;\"Hello Venki!\";} 12345&lt;div align=\"center\"&gt; &lt;audio controls=\"controls\" autoplay=\"autoplay\" loop=\"loop\"&gt; &lt;source src=https://jsdelivr.pai233.top/gh/Wadehl/web-data/MyBlogdata/music/%E5%B0%8F%E9%85%92%E7%AA%9D.mp3 /&gt; &lt;/audio&gt;&lt;/div&gt; 不用网易云： 12345&lt;div align=\"center\"&gt; &lt;audio controls=\"controls\"&gt; &lt;source src=https://jsdelivr.pai233.top/gh/Wadehl/web-data/MyBlogdata/music/%E5%B0%8F%E9%85%92%E7%AA%9D.mp3 /&gt; &lt;/audio&gt;&lt;/div&gt;","categories":[],"tags":[]}],"categories":[{"name":"插画","slug":"插画","permalink":"http://dayswithvenki.top/categories/%E6%8F%92%E7%94%BB/"},{"name":"HEXO","slug":"HEXO","permalink":"http://dayswithvenki.top/categories/HEXO/"},{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"http://dayswithvenki.top/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://dayswithvenki.top/categories/MarkDown/"},{"name":"三角函数","slug":"三角函数","permalink":"http://dayswithvenki.top/categories/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"🐱‍💻GoLang","slug":"🐱‍💻GoLang","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B1%E2%80%8D%F0%9F%92%BBGoLang/"},{"name":"🐲LeetCode","slug":"🐲LeetCode","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%B2LeetCode/"},{"name":"👨‍💻Django","slug":"👨‍💻Django","permalink":"http://dayswithvenki.top/tags/%F0%9F%91%A8%E2%80%8D%F0%9F%92%BBDjango/"},{"name":"💻前端","slug":"💻前端","permalink":"http://dayswithvenki.top/tags/%F0%9F%92%BB%E5%89%8D%E7%AB%AF/"},{"name":"🐍Python","slug":"🐍Python","permalink":"http://dayswithvenki.top/tags/%F0%9F%90%8DPython/"},{"name":"🕷️爬虫","slug":"🕷️爬虫","permalink":"http://dayswithvenki.top/tags/%F0%9F%95%B7%EF%B8%8F%E7%88%AC%E8%99%AB/"},{"name":"🎨像素画","slug":"🎨像素画","permalink":"http://dayswithvenki.top/tags/%F0%9F%8E%A8%E5%83%8F%E7%B4%A0%E7%94%BB/"},{"name":"📖考研英语","slug":"📖考研英语","permalink":"http://dayswithvenki.top/tags/%F0%9F%93%96%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD/"},{"name":"🦋Butterfly","slug":"🦋Butterfly","permalink":"http://dayswithvenki.top/tags/%F0%9F%A6%8BButterfly/"},{"name":"🖥️算法设计与分析","slug":"🖥️算法设计与分析","permalink":"http://dayswithvenki.top/tags/%F0%9F%96%A5%EF%B8%8F%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"👾LaTeX","slug":"👾LaTeX","permalink":"http://dayswithvenki.top/tags/%F0%9F%91%BELaTeX/"},{"name":"🧮三角函数","slug":"🧮三角函数","permalink":"http://dayswithvenki.top/tags/%F0%9F%A7%AE%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"},{"name":"⌨️PTA","slug":"⌨️PTA","permalink":"http://dayswithvenki.top/tags/%E2%8C%A8%EF%B8%8FPTA/"}]}